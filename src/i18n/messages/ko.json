{
  "common": {
    "tools": "도구",
    "language": "언어",
    "theme": "주제",
    "search": "검색",
    "clear": "지우기",
    "copy": "복사",
    "format": "형식화",
    "minify": "압축",
    "convert": "변환",
    "download": "다운로드",
    "generate": "생성",
    "input": "입력",
    "output": "출력",
    "upload_file": "파일 업로드",
    "remove": "제거",
    "copied": "복사 완료",
    "downloaded": "다운로드 완료",
    "error": "오류",
    "success": "성공",
    "copy_failed": "복사 실패",
    "home": "홈",
    "coming_soon": "더 많은 도구가 곧 출시됩니다...",
    "click_sidebar": "왼쪽 메뉴를 클릭하여 사용",
    "actions": "작업",
    "back_to_home": "홈으로 돌아가기",
    "close": "닫기",
    "languages": {
      "en": "English",
      "zh": "中文",
      "es": "Español",
      "de": "Deutsch",
      "fr": "Français",
      "it": "Italiano",
      "pt": "Português",
      "ru": "Русский",
      "ja": "日本語",
      "ko": "한국어",
      "ar": "العربية",
      "hi": "हिंदी"
    }
  },
  "theme": {
    "light": "밝은 모드",
    "dark": "다크 모드",
    "system": "시스템에 따라"
  },
  "header": {
    "title": "IT 도구 모음",
    "subtitle": "개발자를 위한 필수 도구 상자"
  },
  "meta": {
    "site": {
      "title": "IT 도구 모음 - 개발자 도구 상자",
      "name": "IT 도구 모음",
      "description": "개발자를 위해 설계된 온라인 도구 모음으로, JSON 형식화, 텍스트 처리, 암호화/복호화 등 유용한 도구를 포함합니다",
      "keywords": "개발자 도구, 온라인 도구, JSON 도구, 데이터 변환, 텍스트 처리, 프런트엔드 도구, 도구 상자"
    }
  },
  "home": {
    "all_tools": "모든 도구",
    "search_placeholder": "도구 검색...",
    "all_categories": "전체",
    "showing_tools": "총 {count}개 도구",
    "no_tools_found": "일치하는 도구를 찾을 수 없습니다",
    "tools_total": "도구 총수",
    "tools_categories": "도구 분류",
    "update_frequency": "업데이트 빈도",
    "continuously_adding": "계속 추가 중",
    "cover_main_scenarios": "주요 시나리오를 포괄합니다",
    "weekly": "매주",
    "new_tools_features": "새로운 도구와 기능",
    "categories_title": "도구 분류",
    "popular_tools_title": "인기 도구",
    "features_title": "기능 특징",
    "tools_count": "{count}개의 도구",
    "coming_soon": "곧 출시 예정",
    "modern_design": "🎨 현대적 디자인",
    "modern_design_desc": "shadcn/ui를 기반으로 구축되었으며 밝은/다크 테마 전환을 지원하고 우아한 사용자 경험을 제공합니다",
    "multilingual": "🌐 다국어 지원",
    "multilingual_desc": "중국어와 영어 인터페이스를 지원하여 다양한 사용자의 언어 선호를 충족합니다",
    "high_performance": "⚡ 높은 성능",
    "high_performance_desc": "Next.js와 TypeScript를 기반으로 빠른 반응형 사용자 경험을 제공합니다",
    "privacy_protection": "🔒 개인정보 보호",
    "privacy_protection_desc": "모든 도구가 클라이언트에서 실행되어 귀하의 데이터 프라이버시와 보안을 보장합니다",
    "categories_subtitle": "모든 사용 가능한 도구 카테고리와 기능을 살펴보기",
    "popular_tools_subtitle": "개발자들 사이에서 가장 인기 있는 실용 도구 추천",
    "features_subtitle": "현대적 디자인, 다국어 지원, 개인정보 보호를 갖춘 개발자 도구 플랫폼",
    "new_language_announcement": "🎉 이제 독일어(Deutsch) 지원을 시작하게 되어 기쁘게 발표합니다! 응원해 주셔서 감사합니다!"
  },
  "categories": {
    "json_tools": "JSON 유틸리티 도구",
    "json_tools_desc": "JSON용 포맷 정렬, 비교 및 생성을 위한 도우미",
    "json_converters": "포맷 변환기",
    "json_converters_desc": "JSON과 CSV, YAML, XML 형식 간 양방향 변환",
    "json-tools": "JSON 유틸리티 도구",
    "json-converters": "변환기",
    "text": "텍스트 도구",
    "text_desc": "텍스트 처리 및 변환 도구",
    "crypto": "암호화 도구",
    "crypto_desc": "암호화/복호화 및 해시 도구",
    "network": "네트워크 도구",
    "network_desc": "네트워크 디버깅 및 테스트 도구",
    "time": "시간 도구",
    "time_desc": "시간 변환, 시간 차 계산 및 연령 도우미",
    "image": "이미지 도구",
    "image_desc": "이미지 처리 및 변환 도구",
    "developer": "개발자 도구",
    "developer_desc": "Cron, 자동화 등 고급 유용 도구",
    "generators": "생성 도구",
    "generators_desc": "UUID, 비밀번호 등 무작위 데이터 생성 도구",
    "docker": "Docker 도구",
    "docker_desc": "Docker 명령 변환 및 구성 생성 도구"
  },
  "changelog": {
    "title": "업데이트 로그",
    "description": "프로젝트 개발 이력 및 기능 업데이트 기록 보기",
    "lastUpdated": "최근 업데이트",
    "footer": "계속 업데이트 중이며, 더 많은 기능을 기대해 주세요...",
    "meta": {
      "title": "업데이트 로그 - IT 도구 모음",
      "description": "IT 도구 모음 프로젝트의 전체 개발 이력 및 기능 업데이트 기록",
      "keywords": "업데이트 로그, 버전 이력, 개발 이력, 기능 업데이트, 프로젝트 변경사항"
    }
  },
  "tools": {
    "json-formatter": {
      "name": "JSON 포맷터",
      "description": "JSON 데이터를 형식화하고, 검증하며 압축합니다.",
      "placeholder": "JSON 데이터를 입력하세요...",
      "invalid": "유효하지 않은 JSON 형식",
      "formatted": "형식화 완료",
      "input_title": "JSON 입력",
      "output_title": "출력 결과",
      "output_desc": "형식화된 JSON 데이터",
      "output_placeholder": "형식화된 JSON이 여기에 표시됩니다...",
      "introduction": "JSON 포맷터는 개발자를 위해 설계된 강력한 데이터 처리 도구입니다. JSON 데이터를 빠르게 파싱하고, 검증하며 아름답게 정리하는 동시에 실시간 구문 검사, 원클릭 포맷팅, 지능형 압축 기능을 지원합니다. API 디버깅, 구성 파일 편집, 데이터 분석 또는 코드 최적화 등 어떤 상황에서도 편리하고 효율적인 솔루션을 제공합니다. 이 도구는 전적으로 클라이언트에서 실행되므로 민감한 데이터가 항상 안전하고 신뢰할 수 있습니다.",
      "features": [
        "🎯 실시간 JSON 구문 검증 및 스마트 오류 안내",
        "✨ 원클릭으로 포맷을 예쁘게 정리하여 코드 가독성을 대폭 향상시킵니다.",
        "📦 지능형 압축 기능으로 데이터 전송량을 효과적으로 줄입니다.",
        "📋 클립보드로 빠르게 복사하고 간편하게 파일을 다운로드합니다.",
        "🔒 완전한 클라이언트 처리로 데이터 프라이버시를 보호합니다.",
        "⚡ 대용량 파일 처리 지원, 응답 속도가 매우 빠릅니다.",
        "🎨 밝은 테마/다크 테마를 지원하여 눈이 편안합니다.",
        "📱 모바일에 최적화되어 언제 어디서나 사용할 수 있습니다."
      ],
      "faq": [
        {
          "question": "JSON 포맷터 도구가 지원하는 핵심 기능은 무엇인가요?",
          "answer": "저희 JSON 포맷터 도구는 실시간 구문 검증, 원클릭 포맷 정리, 지능형 압축, 빠른 복사, 파일 다운로드 등 전방위적인 JSON 처리 기능을 제공합니다. 모든 작업은 브라우저 로컬에서 이루어지므로 데이터 유출 위험에 대해 걱정할 필요가 없습니다."
        },
        {
          "question": "JSON 형식 오류를 어떻게 빠르게 인식하고 수정할 수 있나요?",
          "answer": "도구 내장 스마트 오류 탐지 시스템이 입력하신 JSON 데이터를 실시간으로 분석합니다. 구문 오류를 감지하면 입력 상자 아래에 자세한 오류 정보와 오류 위치가 표시되어 문제를 신속하게 찾아 수정할 수 있도록 돕습니다."
        },
        {
          "question": "도구가 대형 JSON 파일 처리를 지원하나요?",
          "answer": "네, 저희 도구는 성능 최적화를 거쳐 대형 JSON 파일도 원활하게 처리할 수 있습니다. 최적의 사용자 경험을 보장하기 위해 단일 파일 크기를 10MB를 넘지 않도록 권장합니다. 매우 큰 파일의 경우 적절하게 분할 처리하는 것을 권장합니다."
        },
        {
          "question": "데이터 보안은 어떻게 보장되나요?",
          "answer": "저희는 데이터 보안을 매우 중요하게 여깁니다. 모든 JSON 처리 작업은 로컬 브라우저에서 수행되며 데이터를 어떤 서버에도 업로드하지 않습니다. 귀하의 민감한 정보는 항상 귀하의 관리 하에 있으며 프라이버시가 완전히 보호됩니다."
        },
        {
          "question": "도구가 모바일 기기와 호환되나요?",
          "answer": "완전 호환됩니다! 저희 JSON 포맷터 도구는 반응형 디자인을 채택하여 핸드폰, 태블릿, 데스크탑에서 모두 우수한 사용 경험을 제공합니다. 터치 스크린 조작을 지원하며, 인터페이스가 서로 다른 화면 크기에 맞춰 자동으로 조정됩니다."
        }
      ],
      "meta": {
        "title": "JSON 포맷터 도구 - 온라인 형식화/압축/검증",
        "description": "무료 온라인 JSON 포맷터 도구로 형식화, 압축, 구문 검증을 지원하며, 실시간으로 오류를 하이라이트하고 원클릭 복사/다운로드를 제공합니다. 개발 효율이 향상됩니다.",
        "keywords": "JSON 형식화, JSON 미화, JSON 검증"
      }
    },
    "json-to-csv": {
      "name": "JSON을 CSV로 변환",
      "description": "JSON 데이터를 CSV 형식으로 변환",
      "placeholder": "JSON 데이터를 입력하세요(객체 배열 또는 단일 객체)...",
      "invalid": "유효하지 않은 JSON 형식",
      "invalid_format": "유효한 JSON 객체 또는 객체 배열을 입력하세요",
      "input_title": "JSON 입력",
      "input_desc": "변환할 JSON 데이터를 입력하세요",
      "output_title": "CSV 출력",
      "output_desc": "변환된 CSV 데이터",
      "output_placeholder": "변환된 CSV가 여기에 표시됩니다...",
      "usage_title": "사용 방법",
      "rows_columns": "{rows} 행 × {columns} 열",
      "usage_array_format": "• JSON 객체 배열 형식을 지원합니다:",
      "usage_array_example": "['{\\\"name\\\":\\\"John\\\",\\\"age\\\":25}', ...]",
      "usage_object_format": "• 단일 JSON 객체 형식을 지원합니다:",
      "usage_object_example": "'{\\\"name\\\":\\\"John\\\",\\\"age\\\":25}'",
      "usage_nested_flatten": "• 중첩 객체는 평면화됩니다:",
      "usage_nested_examples": "user.name, user.address.city",
      "usage_array_stringify": "• 배열 값은 JSON 문자열로 변환됩니다",
      "usage_csv_escape": "• CSV 특수 문자 이스케이프의 자동 처리",
      "introduction": "JSON→CSV 변환기는 전문 데이터 형식 변환 도구로, JSON 데이터를 표준 CSV 형식으로 빠르게 변환합니다. JSON 객체 배열과 단일 객체 변환을 지원하고, 중첩 객체를 자동으로 평탄화하며, CSV 특수 문자를 스마트하게 이스케이프합니다. 데이터 내보내기, 보고서 생성, 엑셀 데이터 처리 등 상황에 매우 적합합니다.",
      "features": [
        "📊 JSON 객체 배열과 단일 객체 변환 지원",
        "🔀 지능형 중첩 객체 평탄화 처리",
        "📋 자동 CSV 특수 문자 이스케이프 및 형식화",
        "💾 변환된 CSV 파일을 한 번에 다운로드",
        "⚡ 대규모 데이터 세트를 고성능으로 처리",
        "🔒 클라이언트 측 처리, 데이터의 안전성과 신뢰성 보장"
      ],
      "faq": [
        {
          "question": "어떤 JSON 데이터 형식의 변환을 지원합니까?",
          "answer": "도구는 두 가지 주요 JSON 형식인 객체 배열 형식(예: 사용자 목록, 제품 데이터)과 단일 객체 형식을 지원합니다. 복잡한 중첩 구조에 대해서는 자동으로 평탄화 처리되어 CSV 형식의 호환성을 보장합니다."
        },
        {
          "question": "중첩 객체와 배열은 어떻게 처리합니까?",
          "answer": "중첩 객체는 자동으로 여러 열로 평탄화됩니다(예: user.name, user.address.city). 배열 값은 JSON 문자열 형식으로 저장됩니다. 이렇게 하면 데이터의 완전성을 유지하면서 CSV 형식의 표준성도 보장됩니다."
        },
        {
          "question": "변환된 CSV 파일은 Excel에서 바로 열 수 있나요?",
          "answer": "네, 변환된 CSV 파일은 표준 형식에 완전히 부합하며 Excel, Numbers, Google Sheets 등 스프레드시트 소프트웨어에서 바로 열고 편집할 수 있습니다."
        }
      ],
      "meta": {
        "title": "JSON→CSV 변환기 - 온라인 무료 변환",
        "description": "온라인 JSON→CSV 변환 도구로 중첩 객체와 배열의 지능형 처리 지원, 한 번의 클릭으로 CSV 파일 다운로드, 완전히 무료 무제한.",
        "keywords": "JSON→CSV, JSON 변환기, CSV 내보내기"
      }
    },
    "csv-to-json": {
      "name": "CSV를 JSON으로",
      "description": "CSV 데이터를 JSON 형식으로 변환",
      "placeholder": "CSV 데이터를 입력하세요(첫 행은 헤더)...",
      "invalid_csv": "유효하지 않은 CSV 형식",
      "input_title": "CSV 입력",
      "input_desc": "변환할 CSV 데이터를 입력하세요",
      "output_title": "출력 JSON",
      "output_desc": "변환된 JSON 데이터",
      "output_placeholder": "변환된 JSON이 여기에 표시됩니다...",
      "usage_title": "사용 설명",
      "usage_csv_format": "• 첫 번째 행을 필드명(헤더)으로 사용",
      "usage_auto_type": "• 숫자와 불리언 값 유형 자동 인식",
      "usage_nested_restore": "• 점 표기법으로 구분된 중첩 객체 복원 지원",
      "usage_quoted_values": "• 인용부호가 있는 CSV 값의 자동 처리",
      "usage_json_array": "• 배열 형식의 셀 파싱 지원",
      "introduction": "CSV를 JSON으로 변환하는 변환기는 전문 데이터 형식 변환 도구로, CSV 표 데이터를 빠르게 JSON 형식으로 변환합니다. 데이터 타입 자동 인식, 중첩 객체 복원 지원, CSV 특수 문자와 인용부호를 스마트하게 처리합니다. 데이터 수입, API 연동 및 데이터 분석 등 상황에 매우 적합합니다.",
      "features": [
        "📊 CSV 표 데이터의 스마트 분석",
        "🔀 중첩 객체 구조 자동 복원",
        "🎯 숫자와 불리언 값 유형 스마트 인식",
        "📋 CSV 인용부호 및 특수 문자 처리",
        "💾 변환된 JSON 파일을 한 번에 다운로드",
        "⚡ 대형 데이터 세트를 고성능으로 처리",
        "🔒 클라이언트 측 처리로 데이터의 안전성과 신뢰성을 보장"
      ],
      "faq": [
        {
          "question": "CSV 데이터는 어떤 형식이 필요합니까?",
          "answer": "CSV 데이터의 첫 번째 행은 필드명(헤더)이어야 하며, 이후 각 행은 데이터 행입니다. 표준 콤마 구분을 지원하고, 인용 부문이 있는 값과 중첩된 쉼표도 지원합니다."
        },
        {
          "question": "중첩 객체를 어떻게 복원합니까?",
          "answer": "CSV 헤더가 점 표기법(user.name, user.age)으로 구분되면 도구가 자동으로 중첩된 JSON 객체 구조로 복원합니다."
        },
        {
          "question": "데이터 유형은 어떻게 식별합니까?",
          "answer": "도구는 숫자, 불리언(true/false) 및 JSON 배열을 자동으로 식별합니다. 값이 숫자로 보이고 올바르게 파싱되면 자동으로 숫자 타입으로 변환됩니다."
        }
      ],
      "meta": {
        "title": "CSV→JSON 변환기 - 온라인 무료 변환",
        "description": "온라인 CSV→JSON 변환 도구로, 중첩 객체 복원과 지능형 타입 인식 지원, 한 번의 클릭으로 JSON 파일 다운로드, 완전히 무료 무제한입니다.",
        "keywords": "CSV→JSON, CSV 변환기, JSON 가져오기"
      }
    },
    "json-to-yaml": {
      "name": "JSON을 YAML로",
      "description": "JSON 데이터를 YAML 형식으로 변환하기",
      "placeholder": "JSON 데이터를 입력하세요...",
      "invalid_json": "잘못된 JSON 형식",
      "convert": "YAML로 변환하기",
      "input_title": "JSON 입력",
      "input_desc": "변환할 JSON 데이터를 입력하세요",
      "output_title": "YAML 출력",
      "output_desc": "변환된 YAML 데이터",
      "output_placeholder": "변환된 YAML이 여기에 표시됩니다...",
      "introduction": "JSON⇄YAML 양방향 변환기는 구성 파일 관리와 데이터 교환을 위해 설계된 형식 변환 도구입니다. JSON과 YAML 형식 간의 무손실 양방향 변환을 지원하고, 복잡한 중첩 객체와 배열 구조를 지원하며, 잘 들여쓴 출력을 자동으로 생성합니다. DevOps, 구성 관리, API 문서 등 다양한 시나리오에 적합합니다.",
      "features": [
        "🔄 한 번의 클릭으로 JSON을 YAML 구성 형식으로 변환",
        "📝 표준 포맷 들여쓰기를 자동으로 생성",
        "🎯 복잡한 중첩 객체와 배열 지원",
        "📋 데이터 타입과 구조의 완전성 유지",
        "💾 변환된 파일을 빠르게 다운로드",
        "⚡ 실시간 변환, 즉시 미리보기 효과",
        "🎨 밝은 색상 테마/어두운 테마 지원",
        "🔒 로컬 처리로 데이터 보안 보장"
      ],
      "faq": [
        {
          "question": "JSON을 YAML로 변환하는 데 어떤 시나리오에 적합합니까?",
          "answer": "주로 구성 파일 변환(예: Docker Compose, Kubernetes 구성), API 문서 형식 변환, 데이터 교환 형식 변경 등의 시나리오에 적합합니다. YAML 형식은 읽기 쉬워 사람이 수동으로 편집하고 유지 관리하기에 특히 적합합니다."
        },
        {
          "question": "변환 과정에서 데이터 타입이 손실되나요?",
          "answer": "그렇지 않습니다. 우리 변환기는 데이터 타입의 완전성을 엄격히 유지하며, 문자열, 숫자, 부울 값, 배열, 객체 등 JSON이 지원하는 모든 데이터 타입이 YAML 형식으로 정확하게 매핑됩니다."
        },
        {
          "question": "생성된 YAML 파일은 표준 형식에 부합합니까?",
          "answer": "네, 생성된 YAML 파일은 YAML 1.2 표준 규격에 완전히 부합하며, 어떤 표준 YAML 파서에서도 올바르게 읽을 수 있습니다. 예로 Python의 PyYAML, Ruby YAML, Go의 yaml 등을 포함합니다."
        },
        {
          "question": "특수 문자와 줄 바꿈 문자는 어떻게 처리합니까?",
          "answer": "도구는 YAML의 특수 문자 이스케이프를 자동으로 처리합니다. 줄 바꿈 문자, 따옴표 등 특수 내용이 포함된 문자열의 경우 적절한 YAML 구문(예: 다중 행 문자열, 따옴표로 감싸기 등)을 사용해 형식이 올바르게 되도록 보장합니다."
        }
      ],
      "meta": {
        "title": "JSON→YAML 변환기 - 구성 파일 변환",
        "description": "온라인 JSON→YAML 변환 도구, 구성 파일 변환을 위해 설계되었고 형식화 출력과 구문 검증을 지원하며 한 번의 클릭으로 YAML 파일을 다운로드합니다.",
        "keywords": "JSON→YAML, YAML 변환기, 구성 파일 변환"
      }
    },
    "json-to-toml": {
      "name": "JSON을 TOML으로 변환",
      "description": "JSON 데이터를 TOML 구성 형식으로 변환하기",
      "placeholder": "JSON 데이터를 입력하세요...",
      "invalid_json": "잘못된 JSON 형식",
      "input_title": "JSON 입력",
      "input_desc": "변환할 JSON 데이터를 입력하세요",
      "output_title": "TOML 출력",
      "output_desc": "변환된 TOML 구성",
      "output_placeholder": "변환된 TOML이 여기에 표시됩니다...",
      "introduction": "JSON→TOML 변환기는 전문 구성 파일 형식 변환 도구로, JSON 데이터를 빠르게 TOML 구성 형식으로 변환합니다. TOML은 읽기 쉬운 구성 파일 형식으로, Rust 프로젝트, Python 설정, Go 애플리케이션 등 다양한 시나리오에 널리 사용됩니다. 복잡한 중첩 구조를 지원하고, 데이터 타입을 자동으로 처리하며, 표준 TOML 형식 출력을 생성합니다.",
      "features": [
        "🔄 한 번의 클릭으로 JSON을 TOML 구성 형식으로 변환",
        "📝 읽기 쉬운 TOML 형식 자동 생성",
        "🎯 복잡한 중첩 객체와 배열 지원",
        "📋 데이터 타입과 구조의 완전성 유지",
        "💾 변환된 TOML 파일을 빠르게 다운로드",
        "⚡ 실시간 변환, 즉시 미리보기 효과",
        "🎨 밝은 색상/어두운 색상 테마 지원",
        "🔒 로컬 처리로 데이터 보안 보장"
      ],
      "faq": [
        {
          "question": "JSON을 TOML로 변환은 어떤 시나리오에 적합합니까?",
          "answer": "주로 Rust 프로젝트 구성(Cargo.toml), Python 프로젝트 구성(pyproject.toml), Hugo 정적 사이트, 구성 파일 관리 등의 시나리오에 적합합니다. TOML 형식은 더 간결하고 직관적이며, 수동 편집 및 구성 파일 유지 관리에 특히 적합합니다."
        },
        {
          "question": "변환 과정에서 데이터 타입이 손실되나요?",
          "answer": "그럴 수 없습니다. 저희 변환기는 데이터 타입의 완전성을 엄격히 유지하며, 문자열, 숫자, 불리언, 날짜/시간, 배열, 표 등 TOML이 지원하는 모든 데이터 타입이 정확하게 매핑됩니다."
        },
        {
          "question": "생성된 TOML 파일이 표준 형식에 부합합니까?",
          "answer": "네, 생성된 TOML 파일은 TOML v1.0.0 표준 규격을 완전히 준수하며, 모든 표준 TOML 해석기가 정확하게 읽을 수 있습니다. Rust의 toml 크레이트, Python의 toml 라이브러리 등을 포함합니다."
        }
      ],
      "meta": {
        "title": "JSON을 TOML로 변환하는 컨버터 - 구성 파일 형식 변환",
        "description": "온라인 JSON에서 TOML로 변환 도구로 구성 파일 형식 변환을 지원하며, Rust, Python 등 프로젝트 구성에 적합하고 TOML 파일을 한 번에 다운로드받을 수 있습니다.",
        "keywords": "JSON을 TOML로 변환, TOML 변환기, 구성 파일 변환"
      }
    },
    "toml-to-json": {
      "name": "TOML을 JSON으로",
      "description": "TOML 구성을 JSON 형식 데이터로 변환합니다.",
      "placeholder": "TOML 데이터를 입력하세요...",
      "invalid_toml": "잘못된 TOML 형식",
      "input_title": "입력 TOML",
      "input_desc": "변환할 TOML 구성을 입력하세요",
      "output_title": "JSON 출력",
      "output_desc": "변환된 JSON 데이터",
      "output_placeholder": "변환된 JSON은 여기에서 표시됩니다...",
      "introduction": "TOML을 JSON으로 변환하는 컨버터는 전문적인 구성 파일 형식 변환 도구로, TOML 구성을 빠르게 JSON 형식으로 변환합니다. Cargo.toml, pyproject.toml 등의 구성 파일을 읽고 표준 JSON 형식으로 변환하여 프로그램 처리를 용이하게 합니다. 데이터 구조를 완전하게 유지하고 TOML 고유의 날짜/시간 타입도 자동으로 처리합니다.",
      "features": [
        "🔄 TOML 구성을 한 번에 표준 JSON 형식으로 변환",
        "🎯 다층 중첩 테이블과 배열 구조를 지원",
        "📅 TOML 날짜·시간 타입을 자동으로 처리합니다.",
        "💾 결과 다운로드를 지원하여 저장 및 공유가 용이합니다.",
        "⚡ 브라우저 로컬에서 실시간으로 변환되며 파일 업로드가 필요 없습니다.",
        "🔒 데이터를 업로드하지 않으며 민감한 구성을 안전하게 보호합니다."
      ],
      "faq": [
        {
          "question": "TOML을 JSON으로 변환하는 일반적인 시나리오는 무엇인가요?",
          "answer": "일반적인 시나리오는 다음과 같습니다: Rust 프로젝트의 Cargo.toml, Python 프로젝트의 pyproject.toml 등의 구성 파일을 읽고 JSON으로 변환하여 프로그램에서 사용하도록 합니다; 구성 관리 도구의 TOML 형식을 API가 수용할 수 있는 JSON 형식으로 변환하며; 서로 다른 시스템 간 구성 형식 변환 등을 포함합니다."
        },
        {
          "question": "변환된 JSON이 기존 구성의 의미를 변경하나요?",
          "answer": "그렇지 않습니다. 도구는 TOML의 계층 구조와 데이터 유형을 보존하고 표현 형식만 바꿉니다. 특히 TOML의 날짜/시간 타입은 ISO 8601 문자열 형식으로 변환되어 JSON 호환성을 유지합니다."
        },
        {
          "question": "도구가 큰 TOML 파일을 지원합니까?",
          "answer": "지원합니다. 일반적으로 수백 KB에서 수 MB 규모의 TOML 파일도 정상적으로 변환됩니다. 브라우저 성능에 의존하여 매우 큰 파일은 약간의 지연이 있을 수 있으며, 적절히 분할한 후 변환하는 것을 권장합니다."
        }
      ],
      "meta": {
        "title": "TOML을 JSON으로 변환하는 컨버터 - 구성 파일 형식 변환",
        "description": "온라인 TOML-JSON 변환 도구로 Cargo.toml, pyproject.toml 등 구성 파일 형식을 변환하며, 결과를 한 번에 복사하거나 다운로드할 수 있습니다.",
        "keywords": "TOML을 JSON으로, 구성 변환, TOML 변환기"
      }
    },
    "yaml-to-json": {
      "name": "YAML을 JSON으로",
      "description": "YAML 구성을 JSON 형식 데이터로 변환합니다.",
      "placeholder": "YAML 데이터를 입력하세요...",
      "invalid_yaml": "잘못된 YAML 형식",
      "input_title": "YAML 입력",
      "input_desc": "변환할 YAML 데이터를 입력하세요",
      "output_title": "JSON 출력",
      "output_desc": "변환된 JSON 데이터",
      "output_placeholder": "변환된 JSON은 여기에서 표시됩니다...",
      "introduction": "YAML을 JSON으로 변환하는 컨버서는 구성 마이그레이션과 데이터 통합 시나리오를 위해 설계되었으며, Kubernetes, Docker Compose, CI/CD 구성 등과 같은 일반적인 YAML 구성 파일을 빠르게 구조가 명확한 JSON 형식으로 변환하여 코드에서 직접 사용하거나 각종 API/서비스와 연동하기 쉽습니다. 도구는 복잡한 중첩 구조와 배열을 지원하며 변환된 JSON 데이터가 원래 구성의 시맨틱과 일치하도록 보장합니다.",
      "features": [
        "🔄 YAML 구성을 한 번에 표준 JSON 형식으로 변환",
        "🎯 다층 중첩 객체와 배열 구조를 지원",
        "🧩 프런트엔드/백엔드 코드 및 각종 API와의 직접 통합에 용이합니다.",
        "💾 결과 다운로드를 지원하여 저장 및 공유가 용이합니다.",
        "⚡ 브라우저 로컬에서 실시간으로 변환되며 파일 업로드가 필요 없습니다.",
        "🔒 데이터를 업로드하지 않으며 민감한 구성을 안전하게 보호합니다."
      ],
      "faq": [
        {
          "question": "YAML을 JSON으로 변환하는 일반적인 시나리오는 무엇인가요?",
          "answer": "일반적인 시나리오는 다음과 같습니다: Kubernetes, Docker Compose 등 YAML 구성 파일을 JSON으로 변환하여 코드에 직접 삽입하기 쉽도록 합니다; 운영/구성 팀이 제공한 YAML 파일을 프런트엔드나 백엔드 시스템이 바로 사용할 수 있는 JSON 형식으로 변환; 서로 다른 시스템 간에 데이터 형식을 변환하는 등."
        },
        {
          "question": "변환된 JSON이 기존 구성의 의미를 변경합니까?",
          "answer": "그럴 수 없습니다. 이 도구는 YAML의 계층 구조와 데이터 유형(문자열, 숫자, 불린값, 객체, 배열 등)을 보존하고, 표현 형식만 바꾸며 실제 의미는 바꾸지 않습니다. 중요한 운영 구성 전에 먼저 테스트 환경에서 한 번 검증하는 것을 권장합니다."
        },
        {
          "question": "도구가 더 큰 YAML 파일을 지원합니까?",
          "answer": "지원합니다. 일반적으로 수백 KB에서 수 MB 규모의 YAML 파일도 정상적으로 변환될 수 있습니다. 브라우저 성능 제약으로 인해 매우 큰 파일은 다소 느려질 수 있으므로, 적절히 분할한 뒤 변환하는 것이 좋습니다."
        }
      ],
      "meta": {
        "title": "YAML을 JSON으로 변환하는 변환기 - 구성 파일 형식 변환",
        "description": "온라인 YAML을 JSON으로 변환하는 도구로 다층 중첩 구성과 배열 구조를 지원하며, Kubernetes/Docker 등의 구성 파일 형식 변환에 적합하고 결과를 한 번에 복사하거나 다운로드할 수 있습니다.",
        "keywords": "YAML을 JSON으로, 구성 변환, YAML 변환기"
      }
    },
    "yaml-to-toml": {
      "name": "YAML을 TOML으로",
      "description": "YAML 구성을 TOML 형식으로 변환",
      "placeholder": "YAML 데이터를 입력하세요...",
      "invalid_yaml": "유효하지 않은 YAML 형식",
      "input_title": "YAML 입력",
      "input_desc": "변환할 YAML 구성을 입력",
      "output_title": "출력 TOML",
      "output_desc": "변환된 TOML 구성",
      "output_placeholder": "변환된 TOML이 여기에 표시됩니다...",
      "introduction": "YAML을 TOML으로 변환하는 변환기는 전문적인 구성 파일 형식 변환 도구로, 일반적인 YAML 구성을 빠르게 TOML 형식으로 변환합니다. TOML 형식은 더 간결하고 직관적이며, 특히 Rust 프로젝트, Python 구성 등 상황에 적합합니다. 복잡한 중첩 구조를 지원하고 데이터 유형을 자동으로 처리하며 표준 TOML 형식 출력을 생성합니다.",
      "features": [
        "한 번에 YAML을 TOML 구성 형식으로 변환",
        "가독성이 높은 TOML 형식 자동 생성",
        "복잡한 중첩 객체와 배열 지원",
        "데이터 유형과 구조의 완전성 유지",
        "변환된 TOML 파일을 빠르게 다운로드",
        "실시간 변환, 즉시 미리보기",
        "라이트/다크 테마 지원",
        "로컬 처리, 데이터 보안 보장"
      ],
      "faq": [
        {
          "question": "YAML을 TOML으로 변환하는 데 어떤 환경에 적합합니까?",
          "answer": "주로 Rust 프로젝트 구성(Cargo.toml), Python 프로젝트 구성(pyproject.toml), Hugo 정적 사이트 등에서 사용됩니다. TOML 형식은 YAML보다 더 간단하고, 특히 수동 편집 및 구성 파일 유지 관리에 적합합니다."
        },
        {
          "question": "변환 과정에서 데이터 유형이 손실되나요?",
          "answer": "그렇지 않습니다. 당사의 변환기는 데이터 유형의 완전성을 엄격히 유지하며, 문자열, 숫자, 불리언, 날짜/시간, 배열, 표 등 TOML이 지원하는 모든 데이터 유형을 정확히 매핑합니다."
        },
        {
          "question": "생성된 TOML 파일이 표준 형식에 부합합니까?",
          "answer": "네, 생성된 TOML 파일은 TOML v1.0.0 표준 규격을 완전히 준수하며, 모든 표준 TOML 해석기가 올바르게 읽을 수 있습니다."
        }
      ],
      "meta": {
        "title": "YAML을 TOML으로 변환하는 변환기 - 구성 파일 형식 변환",
        "description": "온라인 YAML을 TOML으로 변환하는 도구로 구성 파일 형식 변환을 지원하며, Rust, Python 등의 프로젝트 구성에 적합하고 TOML 파일을 한 번에 다운로드합니다.",
        "keywords": "YAML을 TOML으로, TOML 변환기, 구성 파일 변환"
      }
    },
    "toml-to-yaml": {
      "name": "TOML을 YAML으로",
      "description": "TOML 구성을 YAML 형식으로 변환",
      "placeholder": "TOML 데이터를 입력하세요...",
      "invalid_toml": "유효하지 않은 TOML 형식",
      "input_title": "TOML 입력",
      "input_desc": "변환할 TOML 구성을 입력",
      "output_title": "출력 YAML",
      "output_desc": "변환된 YAML 구성",
      "output_placeholder": "변환된 YAML이 여기에 표시됩니다...",
      "introduction": "TOML을 YAML로 변환하는 변환기는 전문적인 구성 파일 형식 변환 도구로, TOML 구성을 YAML 형식으로 빠르게 변환합니다. Cargo.toml, pyproject.toml 등의 구성 파일 읽기를 지원하고, 표준 YAML 형식으로 변환되어 Kubernetes, Docker Compose 등의 시나리오에서 사용하기 쉽습니다. 데이터 구조의 완전성을 유지하고 TOML 특유의 데이터 유형을 자동으로 처리합니다.",
      "features": [
        "TOML 구성을 한 번의 클릭으로 표준 YAML 형식으로 변환",
        "다층 중첩 테이블과 배열 구조를 지원",
        "TOML의 날짜/시간 형식을 자동으로 처리",
        "결과 다운로드 지원으로 저장 및 공유가 편리",
        "브라우저 로컬에서 실시간으로 변환, 파일 업로드 불필요",
        "데이터를 업로드하지 않아 구성 파일의 보안을 보호합니다."
      ],
      "faq": [
        {
          "question": "TOML을 YAML으로 변환하는 것은 일반적으로 어떤 시나리오에 사용됩니까?",
          "answer": "일반적인 사용 사례에는 Rust 프로젝트의 Cargo.toml, Python 프로젝트의 pyproject.toml 등의 구성을 Kubernetes, Docker Compose 등 도구에서 사용하도록 YAML로 변환하는 것; 서로 다른 구성 관리 시스템 간 형식 변환; TOML 구성을 보다 일반적인 YAML 형식으로 변환하는 것 등이 포함됩니다."
        },
        {
          "question": "변환된 YAML이 기존 구성의 의미를 바꿀까요?",
          "answer": "그렇지 않습니다. 이 도구는 TOML의 계층 구조와 데이터 타입을 유지하고 표현 형식만 변경합니다. 특히 TOML의 날짜-시간 타입은 YAML의 타임스탬프 형식으로 변환되어 의미의 일관성을 유지합니다."
        },
        {
          "question": "도구는 큰 TOML 파일을 지원합니까?",
          "answer": "지원합니다. 일반적으로 수백 KB에서 수 MB 규모의 TOML 파일도 정상적으로 변환됩니다. 브라우저 성능에 따라 매우 큰 파일은 일부 지연이 발생할 수 있어, 적절히 분할한 후 변환하는 것이 좋습니다."
        }
      ],
      "meta": {
        "title": "TOML→YAML 변환기 - 구성 파일 형식 변환",
        "description": "온라인 TOML→YAML 변환 도구로 Cargo.toml, pyproject.toml 등의 구성 파일 형식 변환을 지원하며 결과를 한 번에 복사하거나 다운로드할 수 있습니다.",
        "keywords": "TOML→YAML, 구성 변환, TOML 변환기"
      }
    },
    "json-to-xml": {
      "name": "JSON→XML 변환기",
      "description": "JSON 데이터를 XML 형식으로 변환합니다.",
      "placeholder": "JSON 데이터를 입력하세요...",
      "invalid": "잘못된 JSON 형식",
      "convert_button": "변환",
      "input_title": "JSON 입력",
      "input_desc": "변환할 JSON 데이터를 입력하세요",
      "xml_input_title": "XML 입력",
      "xml_input_desc": "변환할 XML 데이터를 입력하세요",
      "output_title": "XML 출력",
      "output_desc": "변환된 XML 데이터",
      "json_output_title": "JSON 출력",
      "json_output_desc": "변환된 JSON 데이터",
      "input_placeholder": "변환할 JSON 데이터를 입력하세요...",
      "xml_input_placeholder": "변환할 XML 데이터를 입력하세요...",
      "output_placeholder": "변환된 XML이 여기에 표시됩니다...",
      "json_output_placeholder": "변환된 JSON이 여기에 표시됩니다...",
      "root_element": "루트 요소 이름",
      "errors": {
        "empty_input": "데이터를 입력하세요",
        "invalid_json": "입력된 JSON 형식이 유효하지 않습니다",
        "invalid_xml": "입력된 XML 형식이 유효하지 않습니다"
      },
      "success": "변환 성공",
      "conversion_complete": "JSON→XML 변환 완료",
      "xml_copied": "XML 데이터가 클립보드에 복사되었습니다",
      "xml_downloaded": "XML 파일이 다운로드되었습니다",
      "introduction": "JSON→XML 변환기는 전문 데이터 형식 변환 도구로, JSON에서 XML 형식으로의 정밀한 변환을 제공합니다. XML(확장 가능한 마크업 언어)은 웹 서비스, 구성 파일, 데이터 교환 등의 환경에서 널리 사용되며, 가독성과 구조적 특성이 뛰어납니다. 이 도구는 루트 요소 이름을 사용자 정의할 수 있으며, 중첩된 객체와 배열 구조를 지능적으로 처리해 변환된 XML 형식이 표준화되고 가독성이 높아 다양한 데이터 통합 및 시스템 간 통신 요구를 충족합니다.",
      "features": [
        "🔄 JSON 데이터를 원클릭으로 표준 XML 형식으로 변환 지원",
        "🏷️ JSON→XML 변환 시 루트 요소 이름을 사용자 정의할 수 있습니다",
        "🎯 중첩된 객체와 배열 구조를 지능적으로 처리",
        "⚡ 실시간 변환 처리, 입력 즉시 결과 생성",
        "📋 변환 결과를 원클릭으로 복사하여 통합 개발에 편리합니다",
        "💾 파일 다운로드를 지원하여 데이터 저장 및 전송에 편리합니다",
        "🔒 로컬 처리로 개인정보를 보호하며 데이터가 서버에 업로드되지 않습니다",
        "📱 반응형 설계로 모바일과 데스크톱에서 모두 작동합니다"
      ],
      "faq": [
        {
          "question": "JSON→XML은 어떤 상황에 적용되나요? 이러한 변환이 필요합니까?",
          "answer": "JSON→XML은 주로 시스템 통합, 데이터 교환, 구성 파일 변환 등의 상황에 적용됩니다. 많은 전통 시스템과 기업용 애플리케이션은 여전히 XML 형식을 데이터 교환에 사용하고 있으며, 현대 Web API는 대부분 JSON을 사용합니다. 이 도구는 개발자가 서로 다른 시스템 간에 데이터 형식을 변환하는 데 도움을 주어 데이터 호환성을 보장합니다."
        },
        {
          "question": "변환 과정에서 JSON 배열은 어떻게 처리되나요?",
          "answer": "저희 도구는 JSON 배열을 지능적으로 처리하여 XML의 중복 요소로 변환합니다. 예를 들어 JSON의 배열 [\"item1\", \"item2\"]는 동일한 이름의 XML 요소가 여러 개로 변환됩니다. 복잡한 객체 배열의 경우 각 객체가 독립적인 XML 요소가 되어 원래 데이터 구조를 유지합니다."
        },
        {
          "question": "XML의 루트 요소 이름은 어떻게 사용자 정의합니까?",
          "answer": "도구는 루트 요소 이름을 사용자가 정의할 수 있는 기능을 제공합니다. 필요에 따라 적절한 루트 요소 이름을 설정할 수 있습니다. 이는 특정 XML 스키마를 준수하거나 특정 시스템과의 통합에 매우 중요합니다. 지정하지 않으면 시스템이 기본 루트 요소 이름을 사용합니다."
        },
        {
          "question": "변환된 XML이 표준 형식에 부합합니까?",
          "answer": "네, 저희 도구가 생성한 XML은 W3C XML 표준을 완전히 따릅니다. 변환된 XML은 올바른 구문 구조와 적절한 들여쓰기 형식을 가지며 모든 표준 XML 파서에서 올바르게 해석될 수 있습니다. 또한 특수 문자 이스케이핑도 올바르게 지원합니다."
        },
        {
          "question": "JSON에서 특수 문자와 NULL 값을 어떻게 처리합니까?",
          "answer": "도구는 XML의 특수 문자 이스케이프를 자동으로 처리합니다. 예를 들어 `<`를 `&lt;`로, `&`를 `&amp;`로 변환합니다. JSON의 `null` 값은 빈 XML 요소나 특수 속성 표시로 변환되어 데이터의 완전성과 XML의 유효성을 보장합니다."
        }
      ],
      "meta": {
        "title": "JSON을 XML로 변환하는 변환기 - 데이터 교환 도구",
        "description": "온라인 JSON→XML 변환기, 맞춤 루트 요소를 지원하고, 중첩 데이터 처리를 지능적으로 수행하며, API 데이터 교환 및 구성 파일 변환에 적합합니다.",
        "keywords": "JSON을 XML로, XML 변환기, 데이터 교환"
      }
    },
    "xml-to-json": {
      "name": "XML을 JSON으로 변환하는 변환기",
      "description": "XML 데이터를 빠르게 JSON 형식으로 변환",
      "input_title": "输入 XML",
      "input_desc": "변환할 XML 데이터를 붙여넣거나 입력합니다",
      "output_title": "출력 JSON",
      "output_desc": "변환된 JSON 데이터",
      "placeholder": "변환할 XML 데이터를 입력하세요...",
      "output_placeholder": "변환된 JSON이 여기에 표시됩니다...",
      "invalid_xml": "잘못된 XML 형식입니다. 입력을 확인하세요.",
      "convert_success": "변환 성공!",
      "introduction": "XML을 JSON으로 변환하는 도구는 전문 데이터 형식 변환 도구로, XML(확장 가능 마크업 언어) 데이터를 정확하게 JSON 형식으로 변환할 수 있습니다. XML은 구성 파일, 웹 서비스, 데이터 교환 등에서 널리 사용되고, JSON은 현대 웹 개발의 주류 데이터 형식입니다. 본 도구는 XML 구조를 지능적으로 해석하고 원시 데이터의 계층 관계와 타입 정보를 보존하며, 표준화된 JSON 출력을 생성하고, 복잡한 중첩 구조와 속성 처리를 지원하여 API 통합, 데이터 마이그레이션, 형식 변환을 위한 이상적인 도구입니다.",
      "features": [
        "⚡ 빠른 변환, 실시간 미리보기 변환 결과",
        "🎯 스마트 분석, XML 태그, 속성과 텍스트 내용을 정확하게 처리",
        "🔄 구조를 유지하고 데이터의 계층 관계를 완전히 보존",
        "📋 한 번의 클릭으로 복사, 변환된 JSON 데이터를 빠르게 사용",
        "💾 다운로드 지원, 변환 결과를 저장 및 공유하기 쉽습니다",
        "🔒 로컬 처리, 데이터 보안은 서버로 업로드되지 않음",
        "✨ 포맷된 출력, 읽기 쉬운 JSON 형식 생성",
        "📱 반응형 디자인, 모바일 및 데스크탑 지원"
      ],
      "faq": [
        {
          "question": "XML을 JSON으로 변환하는 것이란 무엇인가요? 왜 이런 변환이 필요한가요?",
          "answer": "XML을 JSON으로 변환하는 과정입니다. 많은 전통 시스템이 XML 형식을 사용하지만, 현대 웹 API와 자바스크립트 애플리케이션은 더 JSON을 선호합니다. 이 도구는 개발자가 서로 다른 시스템 간에 데이터 형식 변환을 수행하도록 도와 개발 효율성과 데이터 호환성을 높입니다."
        },
        {
          "question": "변환 과정에서 XML 속성은 어떻게 처리되나요?",
          "answer": "XML 요소의 속성은 JSON 객체의 특수 필드로 변환됩니다. 보통 '@' 접두사나 '_attributes' 객체를 사용해 속성 값을 저장하며, 속성 정보가 손실되지 않고 요소 내용과 구분되도록 합니다."
        },
        {
          "question": "중복된 XML 요소를 어떻게 처리하나요?",
          "answer": "XML에 동일한 이름의 요소가 여러 개 있을 때, 도구는 이를 지능적으로 JSON 배열로 변환합니다. 예를 들어 여러 개의 <item> 요소는 items 배열로 변환되어 모든 데이터의 완전성을 유지합니다."
        },
        {
          "question": "변환된 JSON 형식이 표준인가요?",
          "answer": "예, 도구가 생성한 JSON은 JSON 표준 규범에 완전히 부합하며, 올바른 문법 구조와 포맷 들여쓰기를 갖추고 있어 어떤 JSON 파서로도 올바르게 해석하고 처리할 수 있습니다."
        },
        {
          "question": "데이터 변환이 안전한가요? 서버에 업로드되나요?",
          "answer": "완전히 안전합니다! 모든 변환 작업은 사용자의 브라우저 로컬에서 수행되며, 데이터를 어떤 서버에도 업로드하지 않습니다. 이는 사용자의 민감한 데이터와 프라이버시를 최대한 보호합니다."
        }
      ],
      "meta": {
        "title": "XML을 JSON으로 변환하는 변환기 - 온라인 파싱 도구",
        "description": "온라인 XML→JSON 변환기, 속성 파싱, 복잡한 중첩 구조 처리 지원, 포맷 출력 및 원클릭 복사 다운로드 기능 제공.",
        "keywords": "XML을 JSON으로, XML 파서, XML 변환기"
      }
    },
    "json-visualizer": {
      "name": "JSON 시각화",
      "description": "트리 구조로 JSON 데이터 표시",
      "placeholder": "JSON 데이터를 입력하세요...",
      "parse_button": "JSON 해석",
      "input_placeholder": "시각화할 JSON 데이터를 입력하세요...",
      "visualization": "시각화",
      "tree_view": "트리 뷰",
      "raw_view": "원시 뷰",
      "no_data": "데이터가 없습니다. 먼저 JSON을 해석하십시오.",
      "type": "유형",
      "size": "크기",
      "depth": "깊이",
      "errors": {
        "empty_input": "JSON 데이터를 입력하세요",
        "invalid_json": "입력된 JSON 형식이 유효하지 않습니다."
      },
      "success": "파싱 성공",
      "parse_complete": "JSON 파싱 완료",
      "json_copied": "JSON 데이터가 클립보드에 복사되었습니다.",
      "introduction": "JSON 시각화 도구는 전문적인 데이터 구조 표시 및 분석 도구로, 복잡한 JSON 데이터를 직관적인 트리 구조로 변환합니다. 인터랙티브한 시각화 UI를 통해 사용자는 JSON 데이터의 계층 관계, 타입 구조 및 콘텐츠 구성을 명확히 이해할 수 있습니다. 이 도구는 데이터 노드의 확장/축소, 타입 식별, 통계 정보 표시 등의 기능을 지원하며, API 응답 디버깅, 구성 파일 분석, 데이터 구조 이해에 도움을 주는 강력한 도구입니다.",
      "features": [
        "🌳 인터랙티브 트리 구조 표시로 JSON의 계층 관계를 명확하게 보여줍니다.",
        "🔍 지능형 유형 식별 및 아이콘 표기로 한눈에 데이터 유형을 파악할 수 있습니다.",
        "📊 실시간 통계 정보 표시, 데이터 크기, 깊이 등 주요 지표를 포함합니다.",
        "⚡ 대용량 데이터 지원, 복잡하게 중첩된 JSON 구조를 원활하게 처리합니다.",
        "🎯 노드 확장/축소 기능으로 필요에 따라 데이터 세부 정보를 확인합니다.",
        "📋 JSON 경로와 노드 값을 빠르게 복사하여 개발 효율을 높입니다.",
        "🎨 우아한 UI 디자인으로 밝은 모드와 다크 모드 간 테마 전환을 지원합니다.",
        "📱 반응형 디자인으로 모바일과 데스크톱에서 완벽한 사용성을 제공합니다."
      ],
      "faq": [
        {
          "question": "JSON 시각화 도구의 장점은 무엇이며 어떤 시나리오에 적합합니까?",
          "answer": "JSON 시각화 도구는 추상적인 JSON 데이터를 직관적인 트리 구조로 변환해 복잡한 데이터 구조를 빠르게 이해도록 돕습니다. 특히 API 디버깅, 구성 파일 분석, 데이터 구조 학습, 백엔드 응답 확인 등 상황에 적합합니다. 순수 텍스트 조회에 비해 시각화는 데이터 이해 효율을 크게 향상시킵니다."
        },
        {
          "question": "도구가 처리할 수 있는 JSON 파일의 최대 크기는 얼마입니까? 성능은 어떻습니까?",
          "answer": "저희 시각화 도구는 성능 최적화를 거쳐 수천 개의 노드를 포함한 대형 JSON 파일도 원활하게 처리할 수 있습니다. 초대형 파일의 경우 한 번 처리 시 5MB를 넘지 않도록 권장하여 최상의 인터랙션 경험을 보장합니다. 도구는 가상 렌더링 기술을 채택하여 대용량이어도 UI 반응성을 유지합니다."
        },
        {
          "question": "JSON에서 특정 데이터를 빠르게 찾는 방법은 무엇인가요?",
          "answer": "도구는 여러 가지 위치 지정 방법을 제공합니다: 1) 트리 구조의 확장/축소 기능을 사용해 계층별로 확인; 2) 노드 타입 아이콘으로 데이터 유형을 빠르게 식별; 3) 통계 정보 표시로 데이터 규모를 이해; 4) JSON 경로 복사를 지원하여 코드에서 데이터를 정확히 액세스하기 쉽습니다."
        },
        {
          "question": "시각화 뷰와 원시 뷰의 차이점은 무엇입니까?",
          "answer": "시각화 뷰는 트리 구조로 JSON을 표시하여 인터랙티브한 데이터 탐색 경험을 제공하고 데이터 구조와 관계를 이해하는 데 적합합니다. 원시 뷰는 포맷된 JSON 텍스트를 표시하고 데이터의 원시 형태를 유지하여 복사 붙여넣기 및 코드 편집에 적합합니다. 두 뷰는 언제든 전환 가능하여 다양한 사용 요구를 충족합니다."
        },
        {
          "question": "도구가 JSON 데이터를 편집하고 수정하는 것을 지원합니까?",
          "answer": "현재 버전은 JSON 데이터의 시각화 표시와 분석에 집중하고 있어 직접 편집은 지원하지 않습니다. 사용자는 필요한 데이터 조각을 복사해 외부 편집기에서 수정한 뒤 다시 가져올 수 있습니다. 우리의 설계 원칙은 최상의 데이터 보기와 이해 경험을 제공하고 도구의 전문성과 안정성을 보장하는 것입니다."
        }
      ],
      "meta": {
        "title": "JSON 시각화 도구 - 트리 뷰어",
        "description": "인터랙티브 JSON 트리 시각화 도구로, 노드 확장/축소, 타입 식별 및 데이터 통계를 지원해 JSON 구조를 직관적으로 분석합니다.",
        "keywords": "JSON 시각화, JSON 뷰어, JSON 트리"
      }
    },
    "json-generator": {
      "name": "JSON 데이터 생성기",
      "description": "테스트용 모의 JSON 데이터 생성",
      "configuration": "설정",
      "record_count": "레코드 수",
      "output_format": "출력 형식",
      "array_format": "배열 형식",
      "object_format": "객체 형식",
      "fields": "필드 구성",
      "add_field": "필드 추가",
      "field_name": "필드 이름",
      "min_value": "최소값",
      "max_value": "최대값",
      "length": "길이",
      "field_type": "필드 유형",
      "string_length": "문자열 길이",
      "array_length": "배열 길이",
      "generate_button": "데이터 생성",
      "output_placeholder": "생성된 JSON 데이터가 이곳에 표시됩니다...",
      "generation_complete": "이미 {count}개의 레코드가 생성되었습니다.",
      "generation_failed": "데이터 생성 실패",
      "json_copied": "JSON 데이터가 클립보드에 복사되었습니다.",
      "json_downloaded": "JSON 파일이 다운로드되었습니다.",
      "output_info": "출력 크기: {size} KB",
      "success": "생성 성공",
      "introduction": "JSON 데이터 생성기는 전문적인 모의 데이터 생성 도구로, 지정된 형식의 JSON 테스트 데이터를 신속하게 생성할 수 있습니다. 문자열, 숫자, 불리언, 날짜, 배열 등 다양한 데이터 타입 구성을 지원하며, 필드 구조와 데이터 범위를 사용자 정의할 수 있습니다. 프런트엔드 개발 테스트, API 인터페이스 디버깅, 데이터베이스 채우기, 성능 테스트 등 다양한 시나리오에 널리 활용되며, 개발자가 대량의 구조화된 모의 데이터를 효율적으로 생성하여 개발 및 테스트 효율을 향상시킵니다.",
      "features": [
        "🎯 다양한 데이터 타입을 지원하며, 문자열, 숫자, 불리언, 날짜를 모두 포괄합니다.",
        "⚙️ 유연한 필드 구성 시스템으로, 필드 이름과 데이터 규칙을 자유롭게 정의합니다.",
        "📊 대량 데이터 생성, 1~10000건의 레코드를 빠르게 생성합니다.",
        "🔧 지능형 데이터 범위 제어, 최소값과 최대값 및 길이 제한을 설정합니다.",
        "📋 다양한 출력 형식, 배열 형식과 단일 객체 형식 출력을 지원합니다.",
        "💾 간편한 데이터 내보내기, 원클릭 복사 및 JSON 파일 다운로드",
        "⚡ 고성능 생성 엔진으로 대량 데이터의 빠른 처리를 지원합니다.",
        "🎨 직관적인 구성 인터페이스, 시각화된 규칙 구성을 제공합니다."
      ],
      "faq": [
        {
          "question": "JSON 데이터 생성기가 어떤 데이터 타입을 지원하며, 어떻게 구성합니까?",
          "answer": "도구는 문자열, 정수, 실수, 불리언, 날짜/시간, 배열 등 다양한 데이터 타입을 지원합니다. 각 타입마다 전용 구성 옵션이 있으며, 예를 들어 문자열은 길이 범위를 설정하고, 숫자는 최소값과 최대값을 설정하며, 날짜는 시간 범위를 설정하는 등 기능이 있습니다. 필드 구성 패널을 통해 다양한 필드를 손쉽게 추가하고 맞춤 설정할 수 있습니다."
        },
        {
          "question": "특정 비즈니스 시나리오에 맞는 테스트 데이터를 어떻게 생성합니까?",
          "answer": "다양한 필드 타입을 조합하여 실제 비즈니스 데이터를 모의할 수 있습니다. 예를 들어 사용자 데이터는 이름(문자열), 나이(숫자), 등록 날짜(날짜) 등의 필드를 포함할 수 있습니다. 도구는 각 필드에 적합한 데이터 범위와 형식을 설정하도록 허용하여 생성된 데이터가 실제 비즈니스 요구에 가깝도록 보장합니다."
        },
        {
          "question": "생성되는 데이터 양에 제한이 있나요? 성능은 어떤가요?",
          "answer": "도구는 1~10000건의 레코드 생성을 지원하여 대부분의 테스트 시나리오 요구를 충족합니다. 생성 엔진은 최적화되어 대량 데이터도 초 단위로 처리될 수 있습니다. 초대형 데이터 세트의 경우 분할 생성하거나 전문 데이터베이스 채우기 도구를 사용하는 것이 좋습니다."
        },
        {
          "question": "생성된 JSON 데이터를 개발에서 어떻게 사용할 수 있나요?",
          "answer": "생성된 JSON 데이터는 코드에 모의 데이터로 바로 복사해 사용할 수 있으며, 파일로 다운로드하여 데이터베이스나 API 테스트 도구에 가져올 수도 있습니다. 배열 형식(목록 데이터에 적합)과 객체 형식(단일 레코드에 적합)을 지원하여 서로 다른 개발 및 테스트 환경에 쉽게 통합할 수 있습니다."
        },
        {
          "question": "생성 데이터의 품질과 일관성을 어떻게 보장합니까?",
          "answer": "도구 내장 데이터 검증 메커니즘으로 생성된 데이터가 설정된 규칙과 타입 제약을 충족하도록 보장합니다. 데이터 범위, 형식 규칙 등을 설정하는 것을 지원하여 데이터의 합리성을 보장합니다. 또한 생성된 데이터는 잘 정의된 난수 분포를 가지므로 데이터가 지나치게 규칙적으로 되어 테스트 효과를 해치지 않도록 합니다."
        }
      ],
      "meta": {
        "title": "JSON 데이터 생성기 - 모의 테스트 데이터 생성",
        "description": "온라인 JSON 모의 데이터 생성기, 다양한 데이터 타입, 유연한 필드 구성 및 대량 생성을 지원하여 개발 및 테스트 요구를 충족합니다.",
        "keywords": "JSON 생성기, 모의 데이터, 테스트 데이터"
      }
    },
    "json-diff": {
      "name": "JSON 차이 비교",
      "description": "두 JSON 데이터의 차이 비교",
      "original": "원시 데이터",
      "modified": "수정 후 데이터",
      "left_placeholder": "원시 JSON 데이터를 입력하세요...",
      "right_placeholder": "수정된 JSON 데이터를 입력하세요...",
      "compare_button": "차이 비교",
      "differences": "차이 결과",
      "show_unchanged": "변경되지 않음 표시",
      "hide_unchanged": "변경되지 않음 숨기기",
      "no_differences": "차이가 발견되지 않았습니다",
      "total": "합계",
      "added_count": "신규",
      "removed": "삭제",
      "modified_count": "수정",
      "unchanged": "변경 없음",
      "errors": {
        "empty_input": "두 개의 JSON 데이터를 입력하세요",
        "invalid_json": "입력된 JSON 형식이 유효하지 않습니다",
        "render_failed": "차이 렌더링 실패",
        "format_failed": "차이 형식화 실패",
        "download_failed": "다운로드 실패"
      },
      "success": "비교 성공",
      "comparison_complete": "차이가 {count}곳 발견되었습니다",
      "report_copied": "차이 보고서가 클립보드에 복사되었습니다",
      "diff_copied": "차이 데이터가 클립보드에 복사되었습니다",
      "diff_downloaded": "차이 파일이 다운로드되었습니다",
      "identical_objects": "두 객체가 완전히 동일합니다",
      "no_differences_found": "어떤 차이도 발견되지 않았습니다",
      "delta_changes": "차이 상세",
      "advanced_options": "고급 옵션",
      "view_mode": "보기 모드",
      "diff_format": "차이 형식",
      "detect_moves": "이동 탐지",
      "visual_mode": "시각화 모드",
      "json_mode": "JSON 모드",
      "raw_mode": "원시 모드",
      "annotated_format": "주석 형식",
      "delta_format": "차이 형식",
      "changes_detected": "{count}곳의 변경이 감지되었습니다.",
      "using_jsondiffpatch": "jsondiffpatch 사용",
      "comparison_result": "비교 결과",
      "side_by_side": "나란히 비교",
      "inline_mode": "인라인 모드",
      "inline_diff_view": "인라인 차이 보기",
      "show_only_differences": "차이만 표시",
      "deleted": "삭제",
      "added_item": "추가",
      "moved": "이동",
      "deleted_marked_red": "삭제된 내용은 빨간색으로 표시",
      "added_marked_green": "추가된 내용은 녹색으로 표시",
      "unified_mode": "통합 모드",
      "unified_diff_view": "통합 차이 보기",
      "detect_moves_explanation_title": "이동 탐지 기능 설명",
      "detect_moves_explanation": "켜 놓으면 배열 원소의 위치 변화를 스마트하게 식별하고, 끄면 이동을 삭제+추가로 인식합니다.",
      "example": "예시",
      "with_move_detection": "이동 탐지 켜기",
      "without_move_detection": "이동 탐지 끄기",
      "moved_from_index": "인덱스에서",
      "to_index": "인덱스로 이동",
      "delete_and_add_separately": "인덱스 0에서 삭제된 A를 표시하고, 인덱스 1에서 추가된 A를 표시",
      "move_detection_enabled": "이동 탐지가 켜져 있습니다",
      "move_detection_disabled": "이동 탐지가 꺼져 있습니다",
      "recalculated": "재계산",
      "differences_only": "차이만",
      "showing_differences_only": "차이 부분만 표시",
      "introduction": "JSON 차이 비교 도구는 전문 데이터 변경 분석 도구로서 두 JSON 데이터 사이의 차이를 심도 있게 비교하고, 정확한 변경 탐지와 시각적 표시를 제공합니다. 첨단 jsondiffpatch 알고리즘을 기반으로 데이터의 추가, 삭제, 수정 및 이동을 스마트하게 인식하며, 버전 관리, 데이터 감사, API 테스트, 구성 비교 등 현장에 강력한 분석 기능을 제공합니다. 도구는 다양한 대조 모드와 출력 형식을 제공하여 개발자가 데이터 변화의 위치를 빠르게 파악하고 이해할 수 있게 도와줍니다.",
      "features": [
        "깊이 있는 차이 탐지로 추가, 삭제, 수정 및 이동 작업을 정확히 식별합니다.",
        "지능형 이동 탐지로 배열 원소의 위치 변화와 추가/삭제를 구분합니다.",
        "다양한 시각화 모드: 나란히 비교, 인라인 표시, 통합 보기",
        "고성능 알고리즘 엔진으로 대형 JSON 데이터 비교를 빠르게 처리합니다.",
        "다양한 출력 형식을 제공하며 JSON 형식과 가독성 높은 보고서를 지원합니다.",
        "색상으로 차이 유형을 구분하여 데이터 변경 상태를 직관적으로 보여줍니다.",
        "간편한 결과 내보내기, 차이 보고서를 한 번의 클릭으로 복사하고 다운로드합니다.",
        "고급 구성 옵션으로 비교 규칙과 표시 방식을 사용자 정의할 수 있습니다."
      ],
      "faq": [
        {
          "question": "JSON 차이 비교 도구가 서로 다른 유형의 변경을 어떻게 식별합니까?",
          "answer": "도구는 jsondiffpatch 알고리즘을 채택하여 네 가지 변경 유형을 스마트하게 식별합니다: 추가(초록색 표시), 삭제(빨간색 표시), 수정(노란색 표시) 및 이동(파란색 표시). JSON 구조를 깊이 순회하여 변경 위치와 내용을 정확히 찾아내고, 완전한 차이 분석 보고서를 제공합니다."
        },
        {
          "question": "이동 탐지 기능은 어떤 용도로 사용되며, 언제 활성화해야 합니까?",
          "answer": "이동 탐지는 배열 원소의 위치 변화를 식별하고 실제 이동 연산과 삭제+추가 연산을 구분합니다. 배열 데이터의 순서 조정, 목록 재정렬 등의 시나리오에 매우 유용합니다. 내용 변화만 신경 쓰고 위치에 관심이 없다면 이 기능을 끄면 차이 보고서를 간소화할 수 있습니다."
        },
        {
          "question": "도구는 어떤 비교 모드를 지원하나요? 각 모드의 특징은 무엇인가요?",
          "answer": "세 가지 비교 모드를 제공합니다: 1) 나란히 비교 - 원본과 수정 버전을 좌우로 표시하여 전체를 한눈에 대조할 수 있습니다; 2) 인라인 모드 - 같은 화면에서 차이점을 표시하여 화면 공간을 절약합니다; 3) 통합 모드 - Git diff와 유사한 표시 방식으로, 개발자가 보기 쉽습니다. 사용 습관에 따라 가장 적합한 모드를 선택할 수 있습니다."
        },
        {
          "question": "대형 JSON 파일의 비교를 어떻게 처리합니까? 성능은 어떻습니까?",
          "answer": "도구는 성능 최적화를 거쳤으며, 효율적인 차이 알고리즘을 사용하여 수천 개의 노드를 포함하는 대형 JSON 파일도 처리할 수 있습니다. 최적의 성능을 보장하려면 단일 파일을 10MB를 넘지 않는 것이 좋습니다. 초대형 파일의 경우 핵심 부분을 먼저 추출해 비교하거나 전문적인 파일 비교 도구를 사용하십시오."
        },
        {
          "question": "차이 보고서를 내보내 저장할 수 있나요? 어떤 형식을 지원하나요?",
          "answer": "다양한 내보내기 방식 지원: 1) 차이 보고서 텍스트를 클립보드에 복사; 2) 차이 데이터를 JSON 형식으로 복사; 3) 전체 차이 파일을 다운로드. 내보낸 보고서는 색상 표기와 서식을 유지하므로 보관·아카이브하거나 팀 구성원과 공유하여 코드 검토 및 데이터 분석에 유용합니다."
        }
      ],
      "meta": {
        "title": "JSON 차이 비교 도구 - 온라인 대조 분석",
        "description": "온라인 JSON 차이 비교 도구로 두 JSON 파일의 차이를 심층 분석하고 시각화된 보고서를 제공하며 데이터 변경을 빠르게 파악합니다.",
        "keywords": "JSON 비교, JSON 차이, 차이 분석"
      }
    },
    "json-key-fixer": {
      "name": "JSON 키 비교 및 수정 도구",
      "description": "다국어 번역 파일의 키 구조 차이를 자동 감지 및 수정합니다.",
      "badge": "번역 파일 유지 관리",
      "drag_files": "드래그 앤 드롭 또는 클릭하여 여러 JSON 파일 업로드",
      "supported_formats": ".json 형식 파일 지원",
      "files": "파일 목록",
      "select_source_hint": "파일을 기준으로 사용할 소스 파일 선택",
      "stats": "차이 통계",
      "order_diff": "순서 차이",
      "missing_keys": "누락된 키",
      "extra_keys": "불필요한 키",
      "match_rate": "일치율",
      "fix_options": "수정 옵션",
      "fix_order": "키 순서 수정",
      "fill_missing": "누락된 키 채우기 (AI 번역)",
      "remove_extra": "불필요한 키 삭제",
      "start_fix": "수정 시작",
      "fixing": "수정 중",
      "download_zip": "ZIP 다운로드",
      "fix_progress": "수정 진행률",
      "translation_progress": "번역 진행률",
      "completed": "완료됨",
      "failed": "실패",
      "language_detected": "언어 감지",
      "confidence": "신뢰도",
      "select_source": "소스 파일 선택",
      "no_source_selected": "먼저 기준이 될 소스 파일을 선택하십시오.",
      "fix_complete": "수정 완료",
      "download_success": "다운로드 성공",
      "upload_success": "업로드 성공",
      "files_uploaded": "{count}개의 파일이 업로드되었습니다.",
      "file_format_error": "잘못된 파일 형식",
      "not_json_file": "{fileName}은(는) JSON 파일이 아닙니다.",
      "file_process_failed": "파일 처리 실패",
      "invalid_json_format": "잘못된 JSON 형식",
      "language_detection_failed": "언어 감지 실패",
      "files_fixed": "{count}개의 파일이 수정되었습니다.",
      "zip_downloaded": "수정된 파일이 압축되어 다운로드되었습니다.",
      "view_details": "상세 정보 보기",
      "diff_dialog_title": "파일 비교 상세 정보",
      "diff_dialog_description": "{fileName}의 수정 전후 비교 보기",
      "diff_stats_order": "순서 차이",
      "diff_stats_missing": "누락된 키",
      "diff_stats_extra": "불필요한 키",
      "diff_stats_match": "일치율",
      "diff_view_title": "JSON 구조 비교",
      "diff_view_description": "빨간색은 삭제를, 녹색은 추가 또는 수정을 나타냅니다.",
      "diff_before": "수정 전 (원본 파일)",
      "diff_after": "수정 후 (처리됨)",
      "introduction": "JSON 키 비교 및 수정 도구는 다국어 번역 파일 유지 관리를 위해 특별히 설계된 전문 도구로, 번역 파일 간의 키 구조 차이를 자동으로 감지하고 수정할 수 있습니다. 지능형 언어 인식, 3차원 차이 분석(순서, 누락, 불필요) 및 AI 번역 보완을 통해 개발 팀이 다국어 파일의 구조 일관성을 유지하도록 돕습니다. 이 도구는 일괄 처리, 시각적 비교, 원클릭 수정을 지원하여 국제화 프로젝트의 유지 관리 효율성을 크게 향상시킵니다.",
      "features": [
        "🔍 스마트 언어 감지 - 대규모 모델 기반 파일 언어 자동 식별",
        "📊 3차원 차이 분석 - 키 순서, 누락, 초과 문제의 세 가지 유형 감지",
        "🤖 AI 번역 보완 - 누락된 키 내용 자동 번역",
        "🔧 원클릭 일괄 수정 - 자동 재정렬 및 번역 보완",
        "📦 ZIP 압축 다운로드 - 수정된 파일 일괄 내보내기",
        "📋 수정 보고서 생성 - Markdown 형식의 상세 보고서",
        "🎯 순서 보존 재구성 알고리즘 - 원본 파일 순서에 따라 엄격하게 재구성",
        "⚡ 동시 번역 엔진 - 50개 항목/배치로 일괄 처리, 효율적인 처리"
      ],
      "faq": [
        {
          "question": "어떤 경우에 JSON 키 비교 및 수정 도구를 사용해야 합니까?",
          "answer": "다국어 번역 파일(예: zh.json, en.json, de.json) 간에 키 구조가 일치하지 않는 경우, 예를 들어 일부 언어 파일에 새로 추가된 번역 키가 누락되었거나 키 순서가 혼란스러워 Git diff를 읽기 어려운 경우, 이 도구는 이러한 문제를 자동으로 감지하고 수정할 수 있습니다."
        },
        {
          "question": "도구는 파일의 언어를 어떻게 감지합니까?",
          "answer": "도구는 JSON 파일에서 처음 10개의 번역 텍스트를 추출하여 대규모 모델로 보내 언어를 식별합니다. 대규모 모델은 언어 특징, 문자 패턴 및 어휘를 분석하여 언어 코드(예: zh, en)와 신뢰도 점수를 반환하여 파일 언어를 정확하게 식별합니다."
        },
        {
          "question": "AI 번역 기능의 정확도는 어떻습니까?",
          "answer": "이 도구는 i18n-json-translator와 동일한 번역 API를 사용하며, 50개 항목/배치로 일괄 처리, 5개의 동시 요청, 최대 3번의 재시도 전략을 채택합니다. 번역 정확도는 대규모 모델 품질에 따라 다르며, 일반적으로 일반적인 언어와 표준 텍스트의 경우 정확도가 매우 높습니다. 번역에 실패한 키는 보고서에 표시되며, 수동으로 보완할 수 있습니다."
        },
        {
          "question": "수정 시 초과 키가 삭제됩니까?",
          "answer": "기본적으로 삭제되지 않습니다. 이 도구는 '초과 키 삭제' 옵션(기본적으로 꺼짐)을 제공하여 대상 파일에서 원본 파일에 없는 키를 제거할지 여부를 선택할 수 있습니다. 예기치 않은 데이터 손실을 방지하기 위해 초과 키를 유지하는 것이 좋으며, 수동으로 검토한 후 삭제 여부를 결정할 수 있습니다."
        },
        {
          "question": "다운로드한 ZIP 파일에는 어떤 내용이 포함되어 있습니까?",
          "answer": "ZIP 파일에는 모든 수정된 JSON 파일(원본 파일 이름 유지)과 README.md 수정 보고서가 포함되어 있습니다. 보고서에는 수정 개요, 번역 통계, 실패한 키 목록이 포함되어 있어 수정 결과를 검토하고 실패한 항목을 수동으로 처리하는 데 편리합니다."
        }
      ],
      "meta": {
        "title": "JSON 키 비교 및 수정 도구 - 다국어 번역 파일 유지 관리",
        "description": "온라인 JSON 키 비교 및 수정 도구는 다국어 번역 파일의 구조적 차이를 자동으로 감지하고 수정하며, 누락된 키를 지능적으로 보완하여 국제화 유지 관리 효율성을 향상시킵니다.",
        "keywords": "JSON 키 수정, 번역 파일 유지 관리, 다국어 도구, i18n 도구"
      }
    },
    "base64-encoder-decoder": {
      "name": "Base64 인코딩/디코딩",
      "description": "Base64 문자열 인코딩 및 디코딩 도구",
      "placeholder": "인코딩/디코딩할 텍스트를 입력하십시오...",
      "encode": "인코딩",
      "decode": "디코딩",
      "input_title": "입력 텍스트",
      "output_title": "출력 결과",
      "output_desc": "인코딩/디코딩된 텍스트",
      "output_placeholder": "인코딩/디코딩 결과가 여기에 표시됩니다...",
      "invalid_base64": "유효하지 않은 Base64 형식",
      "batch_mode": "일괄 모드",
      "batch_mode_desc": "활성화되면 각 행을 독립적으로 인코딩/디코딩합니다.",
      "batch_placeholder": "일괄 인코딩/디코딩할 텍스트를 입력하십시오. 한 줄에 하나의 데이터...",
      "upload_file": "TXT 파일 업로드",
      "file_type_error": ".txt 파일만 지원",
      "file_read_error": "파일 읽기에 실패했습니다. 다시 시도하십시오",
      "introduction": "Base64 인코더/디코더는 전문 문자열 인코딩 변환 도구로, 텍스트, 이진 데이터, Base64 형식 간의 양방향 변환을 지원합니다. 웹 개발, 데이터 전송, 이메일 첨부, 이미지 인코딩 등 다양한 상황에 널리 사용됩니다. 표준 Base64 문자 집합을 사용하여 인코딩/디코딩의 정확성과 호환성을 보장하며, 개발자와 기술자에게 필수 도구입니다.",
      "features": [
        "텍스트를 Base64로 양방향 인코딩/디코딩 지원",
        "실시간 변환, 입력 즉시 결과 표시",
        "표준 Base64 문자 집합으로 호환성이 뛰어납니다",
        "클립보드에 결과를 한 번에 복사",
        "Base64 형식 자동 인식 및 검증",
        "고성능 처리, 대용량 텍스트 변환 지원",
        "로컬에서 처리, 데이터 프라이버시 보안 유지",
        "반응형 디자인, 모바일에 완벽히 적합"
      ],
      "faq": [
        {
          "question": "Base64 인코딩은 어떤 용도로 사용됩니까?",
          "answer": "Base64는 주로 다음과 같은 용도로 사용됩니다: 1) HTTP 프로토콜에서 이진 데이터 전송; 2) 이메일 시스템 첨부 파일 인코딩; 3) URL 안전한 데이터 전송; 4) 이미지를 텍스트 형식으로 변환; 5) API 인증 토큰 인코딩. 이진 데이터를 인쇄 가능한 ASCII 문자로 변환합니다."
        },
        {
          "question": "Base64로 인코딩된 데이터가 커지나요?",
          "answer": "네, Base64 인코딩은 데이터 크기를 약 33% 증가시킵니다. 이는 Base64가 64개의 문자로 256가지 가능성을 표현하기 때문이며, 매 3바이트가 4문자로 인코딩됩니다. 데이터가 커지지만 텍스트 프로토콜에서 이진 데이터를 전송할 수 있는 이점을 얻습니다."
        },
        {
          "question": "도구는 어떤 문자 인코딩을 지원합니까?",
          "answer": "저희 도구는 UTF-8 문자 인코딩을 지원하여 중국어, 영어, 특수 기호 등 다양한 문자를 올바르게 처리할 수 있습니다. 입력 텍스트는 먼저 UTF-8 바이트 시퀀스로 변환된 후 Base64로 인코딩되어 국제화 텍스트의 올바른 처리를 보장합니다."
        },
        {
          "question": "Base64 형식이 올바른지 어떻게 검증합니까?",
          "answer": "유효한 Base64 문자열은 오직 A-Z, a-z, 0-9, +, / 문자만 포함하며 길이는 4의 배수여야 하고, 끝에 '='가 1개 또는 2개가 채워질 수 있습니다. 우리의 도구가 형식을 자동으로 검증하고 디코딩 실패 시 오류 메시지를 제공합니다."
        },
        {
          "question": "Base64 인코딩은 암호화인가요?",
          "answer": "아니요, Base64는 암호화가 아니라 인코딩입니다. 이는 데이터의 표현 방법을 변환하는 것일 뿐이며 누구나 쉽게 디코딩할 수 있습니다. 데이터 보안이 필요한 경우 먼저 데이터를 암호화한 후 Base64로 인코딩하거나, 전용 암호화 도구를 사용해야 합니다."
        }
      ],
      "encoded": "인코딩 완료",
      "decoded": "디코딩 완료",
      "meta": {
        "title": "Base64 인코딩/디코딩 도구 - 온라인 텍스트 변환",
        "description": "온라인 Base64 인코딩/디코딩 도구, 텍스트를 빠르게 인코딩/디코딩할 수 있으며, 데이터 전송, API 개발에 적합합니다. 한 번의 클릭으로 복사.",
        "keywords": "Base64 인코딩, Base64 디코딩, 텍스트 변환"
      }
    },
    "url-encoder-decoder": {
      "name": "URL 인코딩/디코딩",
      "description": "URL 문자열 인코딩 및 디코딩 도구",
      "placeholder": "인코딩/디코딩할 URL 또는 텍스트를 입력하세요...",
      "encode": "인코딩",
      "decode": "디코딩",
      "input_title": "텍스트/URL 입력",
      "output_title": "출력 결과",
      "output_desc": "인코딩/디코딩된 URL",
      "output_placeholder": "인코딩/디코딩 결과가 여기에 표시됩니다...",
      "invalid_url": "유효하지 않은 URL 인코딩 형식",
      "introduction": "URL 인코딩 디코더는 전문적인 URL 처리 도구로, URL 문자열의 인코딩과 디코딩 작업을 지원합니다. RFC 3986 표준을 따르며 한자, 특수 문자, 공백의 URL 내 변환을 정확하게 처리합니다. 웹 개발, API 호출, 검색 엔진 최적화 등 다양한 상황에서 널리 사용할 수 있으며 URL의 올바른 전송과 해석을 보장합니다.",
      "features": [
        "🌐 표준 URL 인코딩/디코딩, RFC 3986 표준에 부합",
        "🇨🇳 중국어와 특수 문자 처리를 완벽하게 지원",
        "⚡ 실시간 변환, 즉시 인코딩 결과 표시",
        "📋 처리된 URL을 한 번에 복사",
        "🔍 URL 형식 자동 인식 및 검증",
        "🎯 전체 URL 및 URL 매개변수 인코딩 지원",
        "🔒 로컬 처리로 URL 프라이버시와 보안을 보장",
        "📱 모바일 최적화, 언제 어디서나 사용 가능"
      ],
      "faq": [
        {
          "question": "URL 인코딩이란 무엇이며, 왜 필요합니까?",
          "answer": "URL 인코딩(퍼센트 인코딩)은 특수 문자를 % 뒤에 16진수로 변환하는 형식입니다. URL은 ASCII 문자만 포함할 수 있기 때문에 한자, 공백, &, 등의 특수 문자는 URL에서 올바르게 전송되려면 인코딩이 필요합니다. 예를 들어 공백은 %20으로, 한자 '你好'는 %E4%BD%A0%E5%A5%BD로 인코딩됩니다."
        },
        {
          "question": "어떤 문자에 URL 인코딩이 필요합니까?",
          "answer": "인코딩이 필요한 문자는 다음과 같습니다: 1) 비 ASCII 문자(예: 중국어); 2) URL 예약 문자(&, =, ?, #); 3) 안전하지 않은 문자(예: 공백, 따옴표); 4) 제어 문자. 안전한 문자(문자, 숫자, -, _, ., ~)는 인코딩이 필요하지 않습니다."
        },
        {
          "question": "URL 인코딩과 HTML 인코딩의 차이점은 무엇입니까?",
          "answer": "URL 인코딩은 퍼센트 기호(%)와 16진수로 표현되며 주로 URL 매개변수에 사용됩니다. HTML 인코딩은 HTML 문서에서 &nbsp; 같은 엔티티 형식으로 사용됩니다. 예를 들어 공백은 URL에서 %20이고 HTML에서 &nbsp;입니다. 두 인코딩의 용도와 규칙은 전혀 다릅니다."
        },
        {
          "question": "URL에서 중국어 매개변수를 어떻게 처리하나요?",
          "answer": "중국어 매개변수는 올바르게 전송되려면 URL 인코딩이 필요합니다. 저희 도구는 UTF-8 인코딩을 사용하여 중국어를 바이트 시퀀스로 변환한 후 퍼센트 인코딩을 수행합니다. 이를 통해 다양한 브라우저와 서버 환경에서 중국어 매개변수의 호환성을 보장합니다."
        },
        {
          "question": "URL 디코딩 실패 시 어떻게 하나요?",
          "answer": "디코딩 실패의 일반적인 원인은: 1) URL 인코딩 형식이 올바르지 않음; 2) 유효하지 않은 16진수 문자 포함; 3) 인코딩이 불완전함. URL의 유효성을 확인하고, % 뒤에 두 자리의 유효한 16진수 숫자가 따라오는지 확인하며, 필요 시 부분 디코딩을 시도할 수 있습니다."
        }
      ],
      "encoded": "인코딩 완료",
      "decoded": "디코딩 완료",
      "meta": {
        "title": "URL 인코딩/디코딩 도구 - encodeURIComponent",
        "description": "온라인 URL 인코딩/디코딩 도구, encodeURIComponent 형식 지원, URL 매개변수 및 특수 문자 이스케이프 처리, 프런트엔드 개발 필수.",
        "keywords": "URL 인코딩, URL 디코딩, encodeURIComponent"
      }
    },
    "uuid-generator": {
      "name": "UUID 생성기",
      "description": "대량으로 UUID 고유 식별자 생성",
      "settings_title": "생성 설정",
      "settings_desc": "UUID 생성 매개변수 구성",
      "count_label": "생성 수",
      "count_hint": "1~1000개의 UUID를 생성할 수 있습니다.",
      "format_label": "출력 형식",
      "format_default": "표준 형식(소문자 하이픈 포함)",
      "format_uppercase": "대문자 형식",
      "format_no_dash": "하이픈 없는 형식",
      "format_no_dash_uppercase": "대문자 하이픈 없는 형식",
      "generate": "UUID 생성",
      "result_title": "생성 결과",
      "result_desc": "일괄로 생성된 UUID 목록",
      "result_placeholder": "생성된 UUID가 여기에서 표시됩니다...",
      "generated_count": "이미 생성된 {count}개의 UUID",
      "about_title": "UUID에 대해",
      "about_uuid_title": "UUID란 무엇인가?",
      "about_uuid_desc": "UUID(범용 고유 식별자)는 128비트의 고유 식별자이며, 시간과 공간에서의 고유성을 보장할 수 있습니다.",
      "about_v4_title": "UUID v4 버전",
      "about_v4_desc": "본 도구는 UUID v4 버전을 사용하며, 전적으로 난수 생성에 기반하고, 충돌 확률이 매우 낮습니다.",
      "about_format_title": "형식 설명",
      "about_format_desc": "표준 형식은 8-4-4-4-12의 16진수 문자이며, 대문자 형식이나 하이픈 없는 형식으로도 선택할 수 있습니다.",
      "about_use_title": "사용 사례",
      "about_use_desc": "데이터베이스 기본 키, 분산 시스템 ID, 파일 명명, API 토큰 등 시나리오에 적합합니다.",
      "introduction": "UUID 생성기는 전문 고유 식별자 대량 생성 도구이며, UUID v4 표준에 기반하고 암호화된 보안 난수 생성 알고리즘을 사용합니다. UUID(범용 고유 식별자)는 분산 시스템에서 널리 사용되며 중앙 집중식 조정 없이도 전 세계적으로 고유성을 보장합니다. 표준 형식, 대문자 형식, 하이픈 없는 형식 등 다양한 출력 형식을 지원하여 서로 다른 시나리오의 요구를 충족합니다. 이 도구는 한 번에 최대 1000개의 UUID를 생성할 수 있어 개발 효율성을 크게 높습니다.",
      "features": [
        "🎲 UUID v4 표준에 따라 완전히 무작위로 생성됩니다.",
        "🔐 암호화된 보안 난수 생성기를 사용합니다.",
        "📊 1~1000개의 UUID를 대량으로 생성합니다.",
        "🎨 표준 형식, 대문자 형식, 하이픈 없는 형식 등 여러 출력 형식을 지원합니다.",
        "📋 모든 UUID를 한 번에 클립보드에 복사합니다.",
        "💾 텍스트 파일로 내보내기 기능을 지원합니다.",
        "⚡ 고성능으로 생성되어 밀리초 단위로 완료됩니다.",
        "🔒 로컬에서 생성되어 보안을 보장합니다."
      ],
      "faq": [
        {
          "question": "UUID란 무엇입니까? 왜 사용합니까?",
          "answer": "UUID(범용 고유 식별자)는 128비트의 식별자이며, 시간과 공간에서 고유성을 가집니다. UUID의 주요 이점은 다음과 같습니다: 1) 중앙 집중식 조정이 없어도 고유성을 보장할 수 있음; 2) 분산 시스템에 적합; 3) 충돌 확률이 매우 낮음(약 1/2^122); 4) 오프라인으로 생성 가능; 5) 생성 시간과 위치 정보를 노출하지 않음."
        },
        {
          "question": "UUID v4란 무엇인가요? 다른 버전과의 차이점은 무엇인가요?",
          "answer": "UUID에는 여러 버전이 있으며, v4는 전적으로 난수 생성에 기반한 버전입니다. 차이점은 다음과 같습니다: 1) v1은 타임스탬프와 MAC 주소를 기반으로 하여 프라이버시가 노출될 수 있음; 2) v3/V5는 네임스페이스와 이름의 해시를 기반으로 하고, v4는 순수 난수 생성(가장 많이 사용됨). v4의 장점은 단순하고 안전하며 하드웨어 정보에 의존하지 않아 대부분의 애플리케이션에 적합합니다."
        },
        {
          "question": "UUID의 충돌 확률은 얼마나 낮습니까?",
          "answer": "UUID v4에는 2^122개의 가능한 값이 있습니다(약 5.3×10^36). 이론적으로 10억 개의 UUID를 생성하면 충돌 확률은 약 1/2^92이며, 우주 방사선으로 인한 컴퓨터 오류의 확률보다 훨씬 작습니다. 실제 응용에서는 UUID 충돌은 불가능에 가깝다고 간주되며 안전하게 사용할 수 있습니다."
        },
        {
          "question": "UUID는 어떤 시나리오에 적합합니까?",
          "answer": "UUID는 광범위하게 사용됩니다: 1) 데이터베이스 기본 키, 특히 분산 데이터베이스; 2) 분산 시스템의 고유 식별자; 3) 파일과 리소스 명명; 4) API 토큰과 세션 ID; 5) 메시지 큐의 메시지 ID; 6) 마이크로서비스 아키텍처의 요청 추적; 7) 캐시 키 생성. 전역적으로 고유한 식별자가 필요한 모든 시나리오에 적합합니다."
        },
        {
          "question": "다양한 형식의 UUID는 어떤 차이가 있나요? 어떻게 선택해야 하나요?",
          "answer": "표준 형식(8-4-4-4-12 하이픈 포함)이 가장 일반적이며, 데이터베이스 저장 및 API 전송에 적합합니다; 대문자 형식은 일부 시스템에서 상수로 사용됩니다; 하이픈 없는 형식은 더 간결하여 URL 및 파일 이름에 적합합니다; 대문자 하이픈 없는 형식은 짧은 코드를 생성하는 데 적합합니다. 선택은 구체적인 요구사항에 따라 다릅니다: 저장 우선이면 하이픈 없는 형식(공간 절약), 가독성 우선이면 표준 형식을 선택합니다."
        }
      ],
      "meta": {
        "title": "UUID 생성기 - 고유 식별자 대량 생성",
        "description": "온라인 UUID 대량 생성 도구로, UUID v4 표준을 지원하고 다양한 출력 형식을 제공하며 전 세계적으로 고유한 식별자를 빠르게 생성합니다.",
        "keywords": "UUID 생성기, 고유 식별자, GUID"
      }
    },
    "password-generator": {
      "name": "비밀번호 생성기",
      "description": "안전하고 신뢰할 수 있는 무작위 비밀번호를 생성합니다.",
      "settings_title": "비밀번호 설정",
      "settings_desc": "사용자 정의 비밀번호 생성 규칙",
      "length": "비밀번호 길이",
      "uppercase": "대문자 포함",
      "lowercase": "소문자 포함",
      "numbers": "숫자 포함",
      "symbols": "특수 문자 포함",
      "exclude_similar": "유사 문자 제외(il1Lo0O)",
      "exclude_ambiguous": "오해의 소지가 있는 문자 제외(대괄호, 원괄호 등)",
      "generate": "비밀번호 생성",
      "result_title": "생성 결과",
      "result_desc": "생성된 비밀번호와 강도 평가",
      "result_placeholder": "생성된 비밀번호가 여기에 표시됩니다...",
      "strength": "비밀번호 강도",
      "weak": "약함",
      "medium": "보통",
      "strong": "강함",
      "no_charset": "적어도 하나의 문자 유형을 선택해야 합니다.",
      "tips_title": "사용 권고",
      "tip1_title": "비밀번호 길이",
      "tip1_desc": "12자리 이상 비밀번호를 사용하는 것을 권장합니다. 길이가 길수록 보안성이 더 높아집니다.",
      "tip2_title": "문자 구성",
      "tip2_desc": "대문자, 소문자, 숫자, 기호를 포함하는 것을 권장합니다.",
      "tip3_title": "정기적으로 변경",
      "tip3_desc": "비밀번호를 정기적으로 변경하고, 여러 계정에서 같은 비밀번호를 사용하지 마십시오.",
      "tip4_title": "안전한 저장",
      "tip4_desc": "비밀번호 관리자를 사용해 비밀번호를 안전하게 저장하고, 평문으로 기록하는 것을 피하십시오.",
      "introduction": "암호 생성기는 전문적인 보안 암호 생성 도구로, 암호학적으로 안전한 난수 생성 알고리즘을 사용하여 고강도이면서 해독하기 어려운 난수 암호를 만들 수 있습니다. 사용자가 비밀번호 길이, 문자 세트 조합, 유사 문자 제외 등 고급 옵션을 커스터마이즈할 수 있으며, 실시간 비밀번호 강도 평가를 제공합니다. 이 도구는 로컬에서 완전히 실행되어 생성된 비밀번호가 전송되거나 저장되지 않도록 하여 사용자의 프라이버시를 최대한 보호합니다.",
      "features": [
        "🔐 암호학적으로 안전한 난수 생성 알고리즘",
        "⚙️ 유연한 암호 구성 옵션, 4-128자리 길이 지원",
        "🎯 지능형 문자 세트 구성, 대소문자, 숫자, 기호를 모두 포함",
        "🔍 유사 문자 제외 기능, 시각적 혼동 방지",
        "📊 실시간 비밀번호 강도 평가, 3단계 보안 등급 표시",
        "📋 생성된 비밀번호를 한 번에 클립보드로 복사",
        "🔒 완전히 로컬에서 생성되어 비밀번호 프라이버시를 안전하게 보호",
        "📱 반응형 디자인, 모바일 기기에서 완벽 지원"
      ],
      "faq": [
        {
          "question": "생성된 비밀번호가 얼마나 안전한가요? 왜 난수 비밀번호를 사용해야 하나요?",
          "answer": "이 도구는 브라우저에 내장된 암호학적으로 안전한 난수 생성기를 사용하여 생성된 비밀번호의 무작위성을 높게 보장합니다. 난수 비밀번호는 일반적이거나 규칙적인 비밀번호에 비해 기하급수적으로 더 높은 보안 이점을 가지며, 12자리의 다양한 문자 구성 난수 비밀번호의 해독 시간은 수만 년에 달합니다."
        },
        {
          "question": "비밀번호 길이는 보통 몇 자로 설정하는 것이 좋나요?",
          "answer": "최소 12자 이상을 권장하며, 16자 이상을 더 권장합니다. 길이가 길수록 보안성은 지수적으로 증가합니다: 8자 비밀번호는 몇 시간 안에 해독될 수 있고, 12자는 수년, 16자는 수만 년에 달합니다. 다만 실제 사용 시나리오를 고려해야 하며, 일부 노후 시스템은 길이 제한이 있을 수 있습니다."
        },
        {
          "question": "왜 유사 문자를 제외하나요? 어떤 경우에 사용하나요?",
          "answer": "'i'와 '1', 'O'와 '0' 같은 유사 문자는 특정 글꼴에서 구분되기 어려워 비밀번호 입력 오류를 일으킬 수 있습니다. 비밀번호를 수동으로 입력하거나 인쇄해야 하는 경우에는 이 옵션을 활성화하는 것이 좋습니다. 다만 이것은 비밀번호 강도를 다소 낮출 수 있으며, 온라인에 저장된 비밀번호의 경우에는 활성화하지 않아도 됩니다."
        },
        {
          "question": "생성된 비밀번호를 안전하게 관리하는 방법은?",
          "answer": "1) 전문 비밀번호 관리자를 사용해 통합 저장하기(예: 1Password, LastPass) 2) 이중 인증 활성화 3) 서로 다른 계정은 서로 다른 비밀번호 사용 4) 중요한 계정의 비밀번호를 정기적으로 변경 5) 브라우저나 평문 파일에 비밀번호를 저장하지 않기"
        },
        {
          "question": "비밀번호 강도 평가는 어떻게 계산되나요?",
          "answer": "시스템은 비밀번호 길이, 문자 유형의 다양성 등의 요소를 종합적으로 고려하여 강도 점수를 계산합니다. 약한 비밀번호(<40점)는 해킹에 취약하고, 중간 비밀번호(40-70점)는 어느 정도 보안이 있으며, 강한 비밀번호(>70점)는 매우 높은 보안을 가집니다. 중요한 계정은 강한 비밀번호를 사용하도록 권장합니다."
        }
      ],
      "meta": {
        "title": "암호 생성기 - 고강도 난수 비밀번호 생성",
        "description": "온라인 보안 비밀번호 생성기, 길이와 문자 집합을 사용자 정의 지원, 고강도 난수 비밀번호를 생성하여 계정 보안을 보호합니다.",
        "keywords": "암호 생성기, 난수 암호, 안전한 비밀번호"
      }
    },
    "aes-encrypt-decrypt": {
      "name": "AES 암호화/복호기",
      "description": "AES 대칭 암호화 알고리즘 암호화/복호 도구",
      "input_title": "입력 데이터",
      "input_desc": "암호화/복호화할 데이터를 입력",
      "input_placeholder": "암호화 또는 복호화할 텍스트를 입력하십시오...",
      "key_label": "키(32자)",
      "key_placeholder": "32자리 키를 입력하거나 생성을 클릭하십시오...",
      "generate_key": "키 생성",
      "iv_label": "초기화 벡터(16자)",
      "iv_placeholder": "16자리 IV를 입력하거나 생성 클릭하십시오...",
      "generate_iv": "IV 생성",
      "mode_label": "암호화 모드",
      "select_mode": "암호화 모드 선택",
      "padding_label": "패딩 모드",
      "select_padding": "패딩 모드 선택",
      "encrypt": "암호화",
      "decrypt": "복호화",
      "output_title": "출력 결과",
      "output_desc": "암호화/복호화된 데이터",
      "output_placeholder": "암호화/복호화 결과가 여기에 표시됩니다...",
      "missing_input_key": "데이터와 키를 입력하세요",
      "missing_input_key_iv": "데이터, 키 및 IV를 입력하세요",
      "decrypt_failed": "복호화에 실패했습니다. 데이터와 키를 확인하세요.",
      "tips_title": "사용 안내",
      "tip1_title": "AES 알고리즘",
      "tip1_desc": "AES(고급 암호화 표준)는 현재 가장 안전한 대칭 암호화 알고리즘 중 하나입니다",
      "tip2_title": "키 보안",
      "tip2_desc": "키 길이는 32자리(256비트)이며, 키를 안전하게 보관하세요",
      "tip3_title": "초기화 벡터(IV)",
      "tip3_desc": "IV는 암호화의 난수성을 높이고, 매번 암호화할 때 서로 다른 IV를 사용해야 합니다",
      "tip4_title": "데이터 보안",
      "tip4_desc": "모든 암호화/복호화는 로컬에서 완료되며, 데이터는 서버로 업로드되지 않습니다",
      "introduction": "AES 암호화/복호화 도구는 고급 암호화 표준(Advanced Encryption Standard)을 기반으로 한 전문 데이터 보안 처리 도구입니다. AES는 미국 국립표준기술연구원(NIST)이 발표한 대칭 암호 알고리즘 표준으로, 정부, 금융, 기업 등 중요 정보 시스템의 데이터 보호에 널리 사용됩니다. 이 도구는 AES-256-CBC 모드를 지원하며, 256비트 키 길이를 사용하고, 산업용 수준의 데이터 보안 보장을 제공합니다. 모든 암호화/복호화 작업은 브라우저 로컬에서 수행되어 데이터 프라이버시를 보장합니다.",
      "features": [
        "🔐 AES-256-CBC 산업용 대칭 암호화 알고리즘, 256비트 키 길이",
        "🛡️ NIST 표준에 부합하며, 정부 및 기업급 보안을 보장합니다",
        "🔑 키와 초기화 벡터(IV)를 자동으로 생성하여 암호화 보안을 보장합니다",
        "⚡ 실시간 암호화/복호화 처리, 대용량 텍스트 데이터 암호화를 지원합니다",
        "📋 한 번의 클릭으로 암호화 결과를 복사하고, 암호문과 키를 편리하게 관리할 수 있습니다",
        "🎯 스마트 오류 검사, 키 형식과 데이터 무결성을 자동으로 검증합니다",
        "🔒 로컬 처리로 개인정보를 보호하며, 암호화 과정은 네트워크 전송을 포함하지 않습니다",
        "📱 반응형 디자인으로 모바일 및 데스크톱에서 작동합니다"
      ],
      "faq": [
        {
          "question": "AES 암호화 알고리즘의 보안성은 얼마나 됩니까? 어떤 상황에 적합합니까?",
          "answer": "AES는 현재 가장 안전한 대칭 암호화 알고리즘 중 하나로 미국 정부가 기밀 정보의 암호화 표준으로 채택했습니다. AES-256은 256비트 키를 사용하며 이론적으로 2^256번의 시도가 필요해 초대형 컴퓨터를 사용하더라도 수십억 년이 걸립니다. 민감한 문서 보호, 데이터베이스 암호화, 통신 암호화, 파일 저장 보안 등과 같은 시나리오에 적합합니다."
        },
        {
          "question": "IV가 왜 필요합니까? 그 역할은 무엇입니까?",
          "answer": "IV는 AES-CBC 모드의 중요한 보안 메커니즘으로, 동일한 평문에 동일한 키를 사용하더라도 매번 암호화 결과가 달라지도록 하여 패턴 분석 공격을 방지합니다. IV는 비밀로 할 필요는 없지만 매번 암호화할 때는 무작위로 생성된 IV를 사용해야 합니다. 본 도구는 안전한 무작위 IV를 자동으로 생성합니다."
        },
        {
          "question": "AES 키는 어떻게 생성하고 관리해야 합니까?",
          "answer": "AES-256 키는 32바이트(256비트)의 무작위 데이터여야 합니다. 우리의 도구는 보안 무작위 키 생성 기능을 제공하며 브라우저의 암호화 보안 난수 생성기를 사용합니다. 실제 사용에서는 키를 안전하게 보관하고 주기적으로 교체하며 전문 키 관리 시스템을 사용하고, 절대 평문으로 저장하거나 안전하지 않은 방식으로 전송해서는 안 됩니다."
        },
        {
          "question": "AES 대칭 암호화와 RSA 비대칭 암호화의 차이점은 무엇입니까?",
          "answer": "AES는 대칭 암호화로, 암호화와 복호화에 동일한 키를 사용하고 암호화 속도가 빠르며 대량의 데이터 암호화에 적합하지만 키 배포가 도전 과제입니다. RSA는 비대칭 암호화로, 공개키와 개인키를 사용하며 공개키로 암호화하고 개인키로 복호화합니다. 키 배포는 안전하지만 암호화 속도는 느립니다. 실제 응용에서 자주 함께 사용합니다: RSA로 AES 키를 전달하고 AES로 실제 데이터를 암호화합니다."
        },
        {
          "question": "AES 키를 잊어버리면 데이터를 해독할 수 있나요?",
          "answer": "그렇지 않습니다. AES 암호화의 보안은 바로 키의 비밀성에 기반하므로 올바른 키가 없으면 데이터를 해독할 수 없습니다. 이것이 AES 설계의 보안 특성이며, 설계자조차도 키를 알지 못하면 데이터를 해독할 수 없습니다. 따라서 키를 안전하게 보관하고 백업하는 것이 매우 중요하며, 전문 키 관리 솔루션의 사용을 권장합니다."
        }
      ],
      "meta": {
        "title": "AES 암호화/복호화 도구 - AES-256-CBC 온라인 암호화",
        "description": "온라인 AES 암호화/복호화 도구로, AES-256-CBC 모드를 지원하며 데이터를 안전하게 보호하는 대칭 암호 알고리즘을 제공합니다.",
        "keywords": "AES 암호화, AES 복호화, 데이터 암호화"
      }
    },
    "rsa-encrypt-decrypt": {
      "name": "RSA 암호화/복호화 도구",
      "description": "RSA 비대칭 암호 알고리즘 도구",
      "encrypt_tab": "암호화/복호화",
      "keygen_tab": "키 생성",
      "input_title": "데이터 입력",
      "input_desc": "암호화/복호화할 데이터를 입력하세요",
      "input_placeholder": "암호화하거나 복호화할 텍스트를 입력하세요...",
      "public_key": "공개키",
      "public_key_label": "공개키(암호화용)",
      "public_key_placeholder": "RSA 공개키를 입력하거나 생성하세요...",
      "private_key": "개인키",
      "private_key_label": "개인키(복호화용)",
      "private_key_placeholder": "RSA 개인키를 입력하거나 생성하세요...",
      "encrypt": "RSA 암호화",
      "decrypt": "RSA 복호화",
      "output_title": "출력 결과",
      "output_desc": "암호화/복호화된 데이터",
      "output_placeholder": "암호화/복호화 결과가 여기에 표시됩니다...",
      "keygen_title": "키 페어 생성",
      "keygen_desc": "RSA 공개키/개인키 쌍 생성",
      "generate_keys": "키 쌍 생성",
      "key_size_label": "키 길이",
      "select_key_size": "키 길이 선택",
      "generate_keypair": "키 쌍 생성",
      "generating": "생성 중...",
      "generated_public_key": "생성된 공개키",
      "generated_private_key": "생성된 개인키",
      "missing_input_key": "데이터와 공개키를 입력하십시오",
      "missing_input_public_key": "데이터와 공개키를 입력하십시오",
      "missing_input_private_key": "데이터와 개인키를 입력하십시오",
      "encrypt_failed": "암호화에 실패했습니다. 데이터와 공개키를 확인하십시오",
      "decrypt_failed": "복호화에 실패했습니다. 데이터와 개인키를 확인하십시오",
      "placeholder": "암호화하거나 복호화할 텍스트를 입력하십시오...",
      "tips_title": "사용 방법",
      "tip1_title": "RSA 알고리즘",
      "tip1_desc": "RSA는 안전한 비대칭 암호화 알고리즘으로, 공개키로 암호화하고 비공개키로 복호화합니다",
      "tip2_title": "키 길이",
      "tip2_desc": "2048비트 이상 키 길이를 권장하며, 더 높은 보안을 제공합니다",
      "tip3_title": "데이터 제한",
      "tip3_desc": "RSA 암호화에는 데이터 길이 제한이 있어 대용량 데이터는 AES+RSA 조합 사용을 권장합니다",
      "tip4_title": "키 관리",
      "tip4_desc": "개인키는 엄격히 비밀로 유지해야 하며, 공개키는 공개적으로 공유할 수 있습니다",
      "introduction": "RSA 암호화/복호화 도구는 전문적인 비대칭 암호 도구로, RSA 알고리즘을 기반으로 안전한 데이터 암호화 및 복호화 서비스를 제공합니다. 키 쌍 생성, 공개키 암호화, 개인키 복호화를 지원하며, 데이터 전송 보안, 디지털 서명, 신원 인증 등 다양한 시나리오에 널리 적용됩니다. RSA는 클래식한 공개키 암호 시스템으로서 수학적 난제를 통해 보안을 보장하며 현대 정보 보안의 중요한 기초입니다. 이 도구는 완전한 RSA 암호화/복호화 기능을 제공하여 사용자가 안전한 데이터 보호를 구현할 수 있도록 돕습니다.",
      "features": [
        "🔐 표준 RSA 알고리즘 구현, 다양한 키 길이 지원",
        "🔑 원클릭으로 RSA 키 쌍 생성, 공개키/개인키 자동 구성",
        "🔒 공개키 암호화 기능으로 민감한 데이터 전송 보호",
        "🔓 개인키 복호화 기능으로 원래 데이터 안전 복구",
        "⚡ 실시간 암호화/복호화, 처리 대기 필요 없음",
        "📋 편리한 복사 및 다운로드 기능",
        "🔧 사용자 정의 키 가져오기 및 관리 지원",
        "🛡️ 클라이언트 측 처리로 데이터 프라이버시 보안 보호",
        "📱 반응형 디자인으로 모바일에 완벽히 적합",
        "🎯 전문급 암호화 강도, 보안 요구사항 충족"
      ],
      "faq": [
        {
          "question": "RSA 암호화 알고리즘이란 무엇이며, 어떤 장점이 있나요?",
          "answer": "RSA는 공개키로 암호화하고 개인키로 복호화하는 비대칭 암호화 알고리즘입니다. 장점으로는 1) 사전에 키를 공유할 필요가 없다; 2) 디지털 서명을 통한 신원 인증이 가능하다; 3) 키 관리가 상대적으로 간단하다; 4) HTTPS, SSH 등 프로토콜에 널리 사용된다; 5) 수학적 기초가 탄탄하며 보안성이 장기간 검증되었다."
        },
        {
          "question": "RSA 키 길이는 몇 비트를 선택하는 것이 좋나요?",
          "answer": "2048비트 이상을 사용할 것을 권장합니다: 1) 1024비트는 더 이상 안전하지 않으므로 사용을 권장하지 않습니다; 2) 2048비트는 현재 최저 권장 표준입니다; 3) 3072비트는 더 높은 보안을 제공합니다; 4) 4096비트는 보안 요구가 큰 상황에 적합합니다. 키가 길수록 보안성은 높아지지만 계산 시간이 증가합니다."
        },
        {
          "question": "RSA로 암호화할 수 있는 데이터 길이는 얼마나 되나요?",
          "answer": "RSA에는 데이터 길이 제한이 있습니다: n비트 키의 경우 최대 암호화 데이터량은 (n/8-11) 바이트입니다. 예를 들어 2048비트 키의 경우 최대 245바이트를 암호화할 수 있습니다. 대용량 데이터의 경우 일반적으로 RSA+AES 하이브리드 암호화를 사용합니다: 데이터를 AES로 암호화하고 AES 키를 RSA로 암호화합니다."
        },
        {
          "question": "공개키와 개인키의 차이점은 무엇인가요? 어떻게 사용하나요?",
          "answer": "공개키는 암호화에 사용되며 공개적으로 공유할 수 있습니다; 개인키는 복호화에 사용되며 엄격히 비밀로 유지해야 합니다. 사용 흐름: 1) 키 쌍을 생성합니다; 2) 공개키를 공개적으로 공유합니다; 3) 다른 사람이 공개키로 데이터를 암호화해 당신에게 보냅니다; 4) 당신은 개인키로 복호화하여 원시 데이터를 얻습니다. 개인키를 분실하면 데이터를 복호화할 수 없습니다."
        },
        {
          "question": "RSA로 암호화된 데이터는 안전합니까? 해독될 수 있나요?",
          "answer": "충분한 길이의 RSA 키를 사용하는 것이 안전합니다. 2048비트 RSA 키는 현재 기술 조건에서 해독하려면 수만 년이 걸립니다. 다만 주의할 점: 1) 신뢰할 수 있는 키 길이를 선택한다; 2) 개인키를 안전하게 보관한다; 3) 키를 정기적으로 교체한다; 4) 측면 채널 공격을 방지한다. 양자 컴퓨팅은 RSA의 보안을 위협할 수 있지만 상용 양자 컴퓨팅은 아직 보급되지 않았다."
        }
      ],
      "meta": {
        "title": "RSA 암호화/복호화 도구 - 키 생성 및 암호화",
        "description": "온라인 RSA 암호화/복호화 도구로, 키 쌍 생성, 공개키로 암호화, 개인키로 복호화를 지원하며 데이터 전송 보안을 보장합니다.",
        "keywords": "RSA 암호화, RSA 키 생성, 비대칭 암호화"
      }
    },
    "md5-hash": {
      "name": "MD5 해시 생성기",
      "description": "MD5 해시 값을 생성하는 도구",
      "placeholder": "MD5를 계산할 텍스트를 입력하세요...",
      "generate": "MD5 생성",
      "input_title": "텍스트 입력",
      "introduction": "MD5 해시 생성기는 전문 데이터 요약 도구로, 임의 길이의 텍스트를 고정 길이의 32자리의 16진수 문자열로 변환할 수 있습니다. 데이터 무결성 검증, 비밀번호 저장, 파일 검증 등 다양한 시나리오에 널리 사용됩니다. MD5는 고안된 보안에 적합하지 않지만 데이터 식별, 캐시 키 생성 등 측면에서 여전히 중요한 가치를 가집니다.",
      "features": [
        "🔐 표준 MD5 알고리즘 구현, 결과 정확하고 신뢰할 수 있습니다",
        "⚡ 실시간 계산, 입력 즉시 해시 값을 생성",
        "📝 임의 길이 텍스트와 특수 문자 지원",
        "📋 한 번의 클릭으로 32자리 16진수 결과를 복사",
        "🎯 고정 길이 출력으로 데이터 식별에 용이",
        "🔍 데이터 무결성 빠른 검증 지원",
        "🔒 로컬 계산으로 데이터 프라이버시를 보호",
        "📱 다중 플랫폼 호환, 모바일 친화적"
      ],
      "faq": [
        {
          "question": "MD5 해시의 용도는 무엇인가요?",
          "answer": "MD5는 주로 다음 용도로 사용됩니다: 1) 데이터 무결성 검증(파일이 수정되었는지 확인); 2) 데이터 중복 제거(동일 내용은 동일 해시 생성); 3) 캐시 키 생성; 4) 데이터 식별자 생성; 5) 간단한 데이터 검증. 주의: MD5는 암호 저장 등 보안 상황에는 적용되지 않습니다."
        },
        {
          "question": "MD5는 안전한가요? 비밀번호 암호화에 사용할 수 있나요?",
          "answer": "MD5는 더 이상 안전한 해시 알고리즘으로 간주되지 않으며 충돌 공격 위험이 있습니다. 비밀번호 저장, 디지털 서명 등 보안 상황에서는 권장되지 않습니다. 비밀번호 암호화에는 bcrypt, scrypt 또는 Argon2 등의 전용 비밀번호 해시 알고리즘을 사용하는 것이 좋습니다."
        },
        {
          "question": "왜 같은 입력은 항상 같은 MD5 값을 생성하나요?",
          "answer": "이는 MD5 알고리즘의 결정적 특성입니다. 같은 입력 데이터가 MD5 연산을 거치면 반드시 같은 해시 값을 생성하며, 이 특성은 MD5를 데이터 무결성 검증 및 중복 제거에 적합하게 만듭니다. 입력에 아주 작은 변화가 있어도 해시 값은 완전히 달라지게 됩니다."
        },
        {
          "question": "MD5 해시 값의 길이는 얼마인가요?",
          "answer": "MD5는 항상 128비트(16바이트)의 해시 값을 생성하며 보통 32자의 16진수 문자로 표시됩니다. 입력 데이터의 길이와 상관없이 MD5 출력 길이는 고정되어 있으며, 이는 해시 함수의 중요한 특성 중 하나입니다."
        },
        {
          "question": "파일의 MD5 값을 어떻게 검증합니까?",
          "answer": "파일 내용을 도구에 복사하여 MD5 값을 생성한 다음 제공된 공식 MD5 값과 대조합니다. 완전히 일치하면 파일이 손상되었거나 변경되지 않았음을 나타냅니다. 다르면 파일이 손상되었거나 위조되었을 수 있습니다. 이는 다운로드한 파일의 무결성을 검증하는 일반적인 방법입니다."
        }
      ],
      "output_title": "MD5 해시 값",
      "output_desc": "생성된 MD5 해시 값",
      "output_placeholder": "MD5 해시 값이 여기에 표시됩니다...",
      "meta": {
        "title": "MD5 해시 생성기 - 온라인 MD5 암호화 도구",
        "description": "온라인 MD5 해시 생성 도구, 텍스트의 MD5 값을 빠르게 계산하며 데이터 검증, 무결성 검증 및 고유 식별에 적합합니다.",
        "keywords": "MD5 해시, MD5 생성기, 데이터 검증"
      }
    },
    "sha256-hash": {
      "name": "SHA256 해시 생성기",
      "description": "SHA256 해시 값을 생성하는 도구",
      "placeholder": "SHA256 해시를 계산할 텍스트를 입력하세요...",
      "generate": "SHA256 생성",
      "input_title": "텍스트 입력",
      "output_title": "SHA256 해시 값",
      "output_desc": "생성된 SHA256 해시 값",
      "output_placeholder": "SHA256 해시 값이 여기에 표시됩니다...",
      "introduction": "SHA256 해시 생성기는 SHA-2 계열에서 가장 중요한 보안 해시 알고리즘으로, 256비트(64개의 16진수 문자)의 고정 길이 요약을 생성합니다. SHA256은 현재 가장 안전한 해시 알고리즘 중 하나로 널리 간주되며, 블록체인, 디지털 인증서, 비밀번호 저장, 데이터 무결성 검증 등 핵심 보안 응용에서 핵심적인 역할을 수행합니다. SHA1과 MD5에 비해 SHA256은 더 강한 보안 보장을 제공합니다.",
      "features": [
        "🔐 SHA-2 계열 최상위 보안 알고리즘, 256비트 강도 보장",
        "⚡ 효율적인 계산, 64자리 16진수 해시 값을 빠르게 생성",
        "📝 임의 길이 데이터 지원, 텍스트에서 대용량 파일까지",
        "📋 한 번의 클릭으로 전체 256비트 해시 값을 복사",
        "🛡️ 충돌 저항이 매우 강하며 보안성이 SHA1/MD5를 훨씬 능가합니다",
        "🎯 고정 64자 출력으로 저장 및 비교에 용이",
        "🔒 로컬 처리로 프라이버시를 보호하며 데이터를 업로드할 필요가 없습니다",
        "📱 모든 플랫폼 호환, 모바일에서도 원활한 사용 경험"
      ],
      "faq": [
        {
          "question": "SHA256은 SHA1 및 MD5에 비해 어떤 이점이 있나요?",
          "answer": "SHA256은 256비트(64자의 16진수 문자)를 출력하며, 안전 강도는 SHA1(160비트) 및 MD5(128비트)보다 현저히 우수합니다. SHA256은 더 강한 충돌 저항성을 가지며 현재 알려진 실제 공격 방법이 없다고 여겨지며 안전한 해시 알고리즘으로 간주됩니다. 비트코인 등 블록체인 시스템에 널리 사용됩니다."
        },
        {
          "question": "SHA256가 블록체인에서 어떤 역할을 합니까?",
          "answer": "SHA256은 비트코인 등 주요 블록체인의 핵심 알고리즘으로, 작업 증명(PoW) 채굴, 블록 해시 계산, 트랜잭션 ID 생성 등에 사용됩니다. 이의 강력한 보안성은 블록체인 데이터의 불가변성을 보장하며, 전체 암호화폐 생태계의 안전한 초석입니다."
        },
        {
          "question": "SHA256은 비밀번호 저장에 적합한가요?",
          "answer": "SHA256 자체는 비밀번호를 직접 저장하기에 적합하지 않습니다. 계산 속도가 빨라 브루트포스 공격에 취약하기 때문이죠. 비밀번호 저장에는 bcrypt, scrypt, Argon2 같은 특수한 느린 해시 알고리즘을 사용해야 합니다. 다만 SHA256은 소금값(salt) 생성, API 키 검증 등의 시나리오에 자주 사용됩니다."
        },
        {
          "question": "파일의 SHA256 무결성을 어떻게 확인합니까?",
          "answer": "파일 내용을 도구에 입력해 SHA256 값을 생성하고, 공식적으로 제공된 체크섬과 비교합니다. 완전히 일치하면 파일이 손상되지 않았음을 의미합니다. 어떤 문자 차이도 파일이 손상되었거나 변조되었을 수 있습니다. 이것이 가장 신뢰할 수 있는 파일 무결성 검증 방법입니다."
        },
        {
          "question": "SHA256 해시 값은 어떤 특징을 갖나요?",
          "answer": "SHA256 출력은 고정된 64개의 16진수 문자(0-9 및 a-f)로 구성됩니다. 예: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855. 입력의 아주 작은 변화는 출력이 완전히 달라지게 하며, 해시 값으로부터 원시 데이터를 역추적할 수 없습니다."
        }
      ],
      "meta": {
        "title": "SHA256 해시 생성기 - 보안 암호화 도구",
        "description": "온라인 SHA256 해시 생성 도구로, 안전한 SHA-256 해시 값을 생성합니다. 암호 저장 및 데이터 무결성 검증에 널리 사용됩니다.",
        "keywords": "SHA256 해시, SHA256 생성기, 비밀번호 암호화"
      }
    },
    "sha1-hash": {
      "name": "SHA1 해시 생성기",
      "description": "SHA1 해시 값을 생성하는 도구",
      "placeholder": "SHA1을 계산할 텍스트를 입력하세요...",
      "generate": "SHA1 생성",
      "input_title": "텍스트 입력",
      "introduction": "SHA1 해시 생성기는 보안 해시 알고리즘 도구로, 임의 길이의 데이터를 160비트(40개의 16진수 문자)의 고정 길이 요약으로 변환할 수 있습니다. SHA1은 MD5보다 더 안전하며, 디지털 서명, 버전 관리 시스템, 데이터 무결성 검증 등에서 널리 사용됩니다. 비록 SHA1은 더 높은 보안이 필요한 애플리케이션에 권장되지 않지만, 많은 전통 시스템에서 여전히 중요한 역할을 합니다.",
      "features": [
        "🔐 표준 SHA1 알고리즘 구현, 160비트 보안 해시",
        "⚡ 실시간 계산, 빠르게 40자리 16진수 요약 생성",
        "📝 임의 길이의 텍스트와 이진 데이터 지원",
        "📋 한 번 눌러 전체 SHA1 해시 값을 복사",
        "🔍 MD5보다 강한 충돌 저항력",
        "🎯 고정된 40자 출력으로 비교 검증이 용이",
        "🔒 로컬 처리로 데이터 프라이버시 안전 확보",
        "📱 기기간 호환, 모바일에서도 완벽 지원"
      ],
      "faq": [
        {
          "question": "SHA1과 MD5의 차이점은 무엇인가요?",
          "answer": "SHA1 출력은 160비트(40개의 16진수 문자)이고, MD5 출력은 128비트(32자)이다. SHA1은 더 강한 보안성과 충돌 저항성을 가지며, Git 버전 관리, 디지털 인증서 등에서 널리 사용된다. SHA1의 계산 복잡도도 MD5보다 약간 높다."
        },
        {
          "question": "SHA1은 아직 안전한가요? 지금도 사용할 수 있나요?",
          "answer": "SHA1은 충돌 공격 가능성이 이론적으로 확인되어 새로운 보안 핵심 애플리케이션에는 권장되지 않습니다. 그러나 파일 무결성 검증, 비핵심 데이터 식별 등의 시나리오에서는 여전히 사용할 수 있습니다. 새 프로젝트에는 SHA-256 또는 그보다 강한 알고리즘 사용을 권장합니다."
        },
        {
          "question": "Git은 왜 SHA1을 사용하나요?",
          "answer": "Git은 SHA1을 객체 식별자로 사용합니다. SHA1은 설계 시에 좋은 분포성과 낮은 충돌 확률을 제공하기 때문입니다. 현재는 더 안전한 알고리즘이 있지만, Git의 설계상 우발적 충돌이 실제 사용에 거의 영향을 주지 않으며 알고리즘을 바꾸려면 큰 호환성 비용이 듭니다."
        },
        {
          "question": "SHA1로 파일 무결성을 어떻게 검증합니까?",
          "answer": "파일 내용을 도구에 입력해 SHA1 값을 생성하고, 공식적으로 제공된 SHA1 요약과 대조합니다. 완전히 일치하면 파일이 손상되지 않았음을 의미하고, 차이가 있으면 파일이 수정되었거나 손상되었을 수 있습니다. 이것은 MD5보다 더 신뢰할 수 있는 무결성 보장을 제공합니다."
        },
        {
          "question": "SHA1 해시 값의 형식은 무엇인가요?",
          "answer": "SHA1 출력은 160비트 이진 데이터로, 일반적으로 40개의 16진수 문자(0-9 및 a-f)로 표시됩니다. 예: da39a3ee5e6b4b0d3255bfef95601890afd80709. 입력 길이에 상관없이 SHA1 출력은 항상 40자로 고정됩니다."
        }
      ],
      "output_title": "SHA1 해시 값",
      "output_desc": "생성된 SHA1 해시 값",
      "output_placeholder": "SHA1 해시 값이 여기에 표시됩니다...",
      "meta": {
        "title": "SHA1 해시 생성기 - Git 버전 관리 도구",
        "description": "온라인 SHA1 해시 생성 도구로, 텍스트의 SHA-1 해시 값을 계산하고 데이터 검증, Git 버전 관리 및 무결성 검증에 사용됩니다.",
        "keywords": "SHA1 해시, SHA1 생성기, Git 해시"
      }
    },
    "hex-encoder-decoder": {
      "name": "16진수 인코더/디코더",
      "description": "16진수 문자열 인코딩/디코딩 도구",
      "placeholder": "인코딩/디코딩할 텍스트나 16진수를 입력하세요...",
      "encode": "Hex로 인코딩",
      "decode": "Hex로 디코딩",
      "input_title": "텍스트 입력",
      "output_title": "출력 결과",
      "output_desc": "인코딩/디코딩된 결과",
      "output_placeholder": "인코딩/디코딩 결과가 여기에 표시됩니다...",
      "invalid_hex": "유효하지 않은 16진수 형식",
      "encoded": "인코딩 완료",
      "decoded": "디코딩 완료",
      "introduction": "16진수 인코더/디코더는 전문적인 16진수 데이터 변환 도구로, 텍스트와 16진수 문자열 간의 양방향 변환을 구현합니다. 16진수 인코딩은 프로그램 개발, 데이터 전송, 디버깅 분석, 암호학 등 분야에서 널리 활용되며, 컴퓨터 과학에서 가장 기본적이고 중요한 데이터 표현 방식 중 하나입니다. 이 도구는 표준 UTF-8 인코딩을 지원하여 중국어 등 다바이트 문자들의 정확한 처리를 보장합니다.",
      "features": [
        "🔄 양방향 변환 지원, 텍스트를 16진수로 변환하고 16진수를 텍스트로 변환",
        "⚡ 실시간 인코딩/디코딩, 입력 즉시 결과 표시",
        "📝 완전한 UTF-8 문자 집합 지원, 중국어 등 다바이트 문자 포함",
        "📋 한 번의 클릭으로 인코딩/디코딩 결과를 클립보드에 복사",
        "🎯 스마트 포맷 검증, 무효한 16진수를 자동으로 감지",
        "🔍 공백 자동 처리, 형식 구분 기호 무시",
        "🔒 로컬 처리로 개인정보를 보호하며 데이터를 업로드할 필요가 없습니다.",
        "📱 모바일에 완벽히 최적화된 반응형 디자인"
      ],
      "faq": [
        {
          "question": "16진수 인코딩이란 무엇이며, 왜 사용합니까?",
          "answer": "16진수 인코딩은 바이트 데이터를 0-9와 A-F 문자로 표현하는 방법으로, 각 바이트는 두 개의 16진수 문자로 표현됩니다. 이것은 이진수보다 더 간결하고, 십진수보다 컴퓨터 내부 데이터를 더 직관적으로 표현합니다. 메모리 주소, 색상 코드, 암호 키 등 다양한 용도에 널리 사용됩니다."
        },
        {
          "question": "왜 제 중국어 문자는 인코딩하면 이렇게 길어지나요?",
          "answer": "중국어 등 다바이트 문자는 UTF-8 인코딩에서 보통 3바이트를 차지하고, 각 바이트를 2개의 16진수 문자로 변환하므로 하나의 중국어 문자는 6개의 16진수 문자로 생성됩니다. 이는 정상적인 인코딩 동작으로, 문자의 완전성과 국제화 지원을 보장합니다."
        },
        {
          "question": "16진수 인코딩과 Base64 인코딩의 차이가 무엇인가요?",
          "answer": "16진수는 16개의 문자(0-9, A-F)를 사용하며, 각 문자는 4비트를 나타냅니다. 인코딩 후 길이는 원시 데이터의 두 배입니다. Base64는 64개의 문자를 사용하고 각 문자는 6비트를 나타내므로 인코딩 길이는 원시 데이터의 약 1.33배로 더 간결하지만 가독성은 다소 떨어집니다."
        },
        {
          "question": "프로그래밍에서 16진수 데이터를 어떻게 처리하나요?",
          "answer": "대다수의 프로그래밍 언어에는 16진수 지원이 내장되어 있습니다. JavaScript에서는 parseInt(hex, 16)로 파싱하고, toString(16)으로 변환합니다. Python은 hex()와 int(hex_str, 16)을 사용합니다. 16진수는 비트 연산, 메모리 디버깅, 프로토콜 해석 등의 저수준 프로그래밍 상황에서 자주 사용됩니다."
        },
        {
          "question": "왜 16진수 문자열은 짝수 길이여야 하나요?",
          "answer": "각 바이트는 두 개의 16진수 문자로 표시되므로 홀수 길이의 문자열은 전체 바이트 경계에 올바르게 대응하지 못합니다. 홀수 길이를 만날 경우 일반적으로 앞에 0을 보충하거나 데이터의 완전성을 확인해야 합니다."
        }
      ],
      "meta": {
        "title": "16진수 인코더/디코더 - 16진수 변환 도구",
        "description": "온라인 16진수 인코딩/디코딩 도구로, 텍스트와 16진수 문자열 간 상호 변환을 지원하며, 데이터 처리, 디버깅 및 개발에 적합합니다.",
        "keywords": "16진수 인코딩, 16진수 변환, 16진수 디코딩"
      }
    },
    "binary-encoder-decoder": {
      "name": "이진 인코더/디코더",
      "description": "이진 문자열 인코딩/디코딩 도구",
      "placeholder": "인코딩/디코딩할 텍스트나 이진 데이터를 입력하세요...",
      "encode": "Binary로 인코딩",
      "decode": "Binary에서 디코딩",
      "input_title": "입력 텍스트",
      "output_title": "출력 결과",
      "output_desc": "인코딩/디코딩 후의 결과",
      "output_placeholder": "인코딩/디코딩 결과가 여기에 표시됩니다...",
      "invalid_binary": "유효하지 않은 이진 형식",
      "encoded": "인코딩 완료",
      "decoded": "디코딩 완료",
      "introduction": "이진 수 인코더/디코더는 전문적인 이진 데이터 처리 도구로, 텍스트와 이진 문자열 간의 정확한 변환을 구현합니다. 이진수는 컴퓨터의 저수준 언어로서, 컴퓨터의 작동 원리와 데이터 저장 메커니즘을 이해하는 기초입니다. 이 도구는 표준 UTF-8 인코딩 방식을 채택하여 중국어 등 다바이트 문자의 정확한 처리를 보장하며, 컴퓨터 과학 교육, 저수준 프로그래밍 디버깅, 데이터 분석 등 전문 분야에 널리 응용됩니다.",
      "features": [
        "🔢 표준 이진 인코딩 변환, 각 문자는 8비트 이진수로 변환",
        "⚡ 실시간 변환 처리, 입력 즉시 변환 결과 표시",
        "📝 완전한 UTF-8 문자 집합 지원, 중국어 등 다바이트 문자 포함",
        "📋 한 번의 클릭으로 인코딩/디코딩 결과를 클립보드에 복사",
        "🎯 스마트 포맷 검증, 무효한 이진 시퀀스를 자동으로 감지",
        "🔍 공백 자동 처리, 포맷된 이진 표시를 지원",
        "🔒 로컬 처리로 프라이버시 보호, 모든 변환이 브라우저에서 로컬로 완료됩니다",
        "📱 반응형 디자인, 모바일 및 데스크톱 기기를 지원"
      ],
      "faq": [
        {
          "question": "이진 인코딩이란 무엇이며, 어떤 용도가 있나요?",
          "answer": "이진 인코딩은 문자를 0과 1로 구성된 이진 숫자 시퀀스로 변환하는 것입니다. 각 문자는 해당 UTF-8 인코딩의 바이트 값을 따라 8비트 이진수로 변환됩니다. 이진 인코딩은 주로 컴퓨터 과학 교육, 데이터 저장 원리 이해, 저수준 프로그래밍 디버깅 및 디지털 회로 설계 등 분야에 사용됩니다."
        },
        {
          "question": "왜 하나의 중국어 문자로 이렇게 많은 이진 비트가 생성되나요?",
          "answer": "중국어 문자는 UTF-8 인코딩에서 보통 3바이트를 차지하고, 각 바이트는 8비트를 포함하므로 하나의 중국어 문자는 총 24비트(3×8=24)의 이진수 비트를 생성합니다. 이는 중국어 문자의 완전한 표현과 국제화 호환성을 보장하며, 유니코드 표준의 정상적인 인코딩 방식입니다."
        },
        {
          "question": "이진 인코딩과 ASCII 인코딩의 차이점은 무엇인가요?",
          "answer": "ASCII 인코딩은 기본 영어 문자 128개만 표현할 수 있으며, 각 문자는 7비트로 표현됩니다. 반면 우리의 이진 인코딩은 UTF-8을 기반으로 전 세계의 모든 문자(중국어, 이모지 등)를 표현할 수 있습니다. UTF-8은 ASCII와 하위 호환되지만 더 넓은 문자 지원을 제공합니다."
        },
        {
          "question": "컴퓨터에서 이진 데이터가 저장되는 방식을 어떻게 이해할 수 있나요?",
          "answer": "컴퓨터 내부의 모든 데이터는 이진 형태로 저장됩니다. 8개의 이진 비트(0 또는 1)가 모여 하나의 바이트를 이루며, 이것이 컴퓨터 저장의 기본 단위입니다. 이진 인코딩을 이해하면 컴퓨터가 텍스트, 그림, 프로그램 등 다양한 데이터를 어떻게 저장하는지 이해하는 데 도움이 됩니다."
        },
        {
          "question": "이진 문자열은 반드시 8의 배수여야 하나요?",
          "answer": "네, UTF-8 인코딩은 바이트 단위이며 각 바이트에 8비트가 고정적으로 포함됩니다. 이진 문자열의 길이가 8의 배수가 아니면 일반적으로 데이터가 불완전하거나 오류가 있음을 나타냅니다. 디코딩할 때 이 조건을 확인하여 데이터의 무결성을 보장합니다."
        }
      ],
      "meta": {
        "title": "바이너리 인코더-디코더 - 이진 변환 도구",
        "description": "온라인 이진 인코딩/디코딩 도구로 텍스트와 이진 간의 상호 변환을 지원하며 데이터 분석, 디버깅 및 프로그래밍 학습에 적합합니다.",
        "keywords": "바이너리 인코딩, 이진 변환, 바이너리 디코드"
      }
    },
    "qr-code-generator": {
      "name": "QR 코드 생성기",
      "description": "사용자 정의 QR 코드 이미지를 생성합니다.",
      "placeholder": "생성할 QR 코드의 내용을 입력하세요...",
      "input_title": "내용 입력",
      "input_desc": "텍스트, URL 또는 기타 내용을 입력하세요.",
      "output_title": "생성된 QR 코드",
      "output_desc": "생성된 QR 코드 이미지",
      "size_label": "크기",
      "select_size": "QR 코드 크기 선택",
      "error_correction_label": "오류 수정 수준",
      "select_error_correction": "오류 수정 수준 선택",
      "foreground_color": "전경색",
      "background_color": "배경색",
      "format_label": "내보내기 형식",
      "select_format": "내보내기 형식 선택",
      "generate_button": "QR 코드 생성",
      "download_png": "PNG 다운로드",
      "download_svg": "SVG 다운로드",
      "copy_image": "이미지 복사",
      "qr_copied": "QR 코드가 클립보드에 복사되었습니다",
      "qr_downloaded": "QR 코드 파일이 다운로드되었습니다.",
      "empty_content": "내용을 입력하세요.",
      "generate_failed": "QR 코드 생성에 실패했습니다.",
      "sizes": {
        "small": "작은 (128x128)",
        "medium": "중간 (256x256)",
        "large": "큰 (512x512)",
        "xlarge": "특대형 (1024x1024)"
      },
      "error_levels": {
        "L": "낮음 (7%)",
        "M": "중간 (15%)",
        "Q": "다소 높음 (25%)",
        "H": "높음 (30%)"
      },
      "tips_title": "사용 방법",
      "tip1_title": "콘텐츠 유형",
      "tip1_desc": "텍스트, URL, 전화번호, 이메일, Wi-Fi 구성 등 다양한 콘텐츠 유형을 지원합니다",
      "tip2_title": "크기 선택",
      "tip2_desc": "사용 시나리오에 따라 적합한 크기를 선택하고, 인쇄 용도에는 대형 크기를 권장합니다.",
      "tip3_title": "오류 수정 수준",
      "tip3_desc": "오류 수정 수준이 높아질수록 QR 코드는 더 복잡해지지만 오류 수정 능력은 더 강해집니다.",
      "tip4_title": "색상 설정",
      "tip4_desc": "전경색과 배경색의 충분한 대비를 유지하여 스캔 인식을 보장합니다.",
      "introduction": "QR 코드 생성기는 전문적인 QR 코드 제작 도구로, 텍스트, URL, 연락처 정보, WiFi 구성 등 다양한 데이터를 고품질의 QR 코드 이미지로 변환하는 것을 지원합니다. QR 코드(QR Code)는 현대 디지털 생활의 중요한 수단으로, 결제, 마케팅, 정보 공유, 제품 추적 등 다양한 상황에서 널리 활용됩니다. 이 도구는 크기 조절, 색상 구성, 오류 수정 수준 설정 등 풍부한 사용자 정의 옵션을 제공하고, PNG와 SVG 두 형식으로 내보내기를 지원하여 생성된 QR 코드가 최상의 스캔 인식률과 시각적 효과를 갖도록 보장합니다.",
      "features": [
        "다양한 콘텐츠 유형 지원: 텍스트, URL, 전화번호, 이메일, WiFi 설정",
        "유연한 사이즈 선택: 128x128에서 1024x1024 픽셀까지, 다양한 애플리케이션 요구에 부합",
        "색상 구성 커스텀: 전경색과 배경색을 자유롭게 조절하여 시각 효과를 강화",
        "스마트 오류 정정 수준: 4단계 정정 설정으로 복잡도와 오류 허용도를 균형 있게 조절",
        "이중 포맷 내보내기: PNG 비트맵 및 SVG 벡터 포맷 다운로드 지원",
        "원터치 복사 기능: 편리한 클립보드 작동으로 디자인 프로세스에 빠르게 통합",
        "로컬 생성으로 개인 정보 보호: 모든 작업이 브라우저에서 로컬로 수행됩니다",
        "반응형 디자인: 모바일과 데스크톱 양쪽에서 완벽하게 작동"
      ],
      "faq": [
        {
          "question": "QR 코드가 어떤 콘텐츠 유형을 지원하나요? 유형별로 어떻게 최적화하나요?",
          "answer": "당사 QR 생성기는 순수 텍스트, 웹 링크, 전화번호, 이메일, WiFi 설정 정보, 연락처 정보(vCard) 등 다양한 콘텐츠 유형을 지원합니다. URL의 경우 복잡도를 줄이려면 짧은 링크를 사용하는 것이 좋고, WiFi 설정은 네트워크 이름과 비밀번호를 직접 입력할 수 있으며, 연락처 정보는 표준 vCard 형식을 지원하여 다양한 기기에서 올바르게 인식되도록 보장합니다."
        },
        {
          "question": "적합한 QR 코드 크기와 오류 정정 수준을 어떻게 선택하나요?",
          "answer": "사이즈 선택은 사용 환경에 따라 달라집니다: 웹페이지 표시용은 256x256, 인쇄물의 경우 512x512 이상 권장. 오류 정정 수준은 L(7%)은 깨끗한 환경에 적합, M(15%) 일반 권장, Q(25%) 약간 손상 가능 환경에 적합, H(30%) 악천후 환경이나 장기간 보관이 필요한 경우에 적합."
        },
        {
          "question": "QR 코드 색상 설정에 어떤 요구사항이 있나요? 스캔 성공률은 어떻게 보장하나요?",
          "answer": "QR 코드의 핵심은 전경색(코드 점)과 배경색 사이에 충분한 대비가 있어야 한다는 점입니다. 어두운 전경색에 밝은 배경색을 추천합니다(예: 검은색과 흰색). 빨간 계열의 전경색 사용은 피하는 것이 좋습니다(일부 스캐너가 인식하기 어렵습니다). 그라데이션 색상이나 서로 너무 비슷한 색상도 인식률에 영향을 줍니다. 저희 도구는 대비를 자동으로 감지하고 제안을 제공합니다."
        },
        {
          "question": "PNG와 SVG 형식의 차이점은 무엇인가요? 어떻게 선택해야 하나요?",
          "answer": "PNG은 비트맷 형식으로 바로 사용하고 공유하기에 적합합니다. 파일이 작고 호환성이 좋으며 웹 페이지, 소셜 미디어, 인쇄 등에 적합합니다. SVG는 벡터 형식으로 무한히 확대해도 왜곡이 없고, 크기를 조정해야 하는 디자인 프로젝트, 로고 제작, 전문 인쇄 등에 적합합니다. 후속 편집이나 대폭 확대가 필요한 경우 SVG 형식을 권장합니다."
        },
        {
          "question": "생성된 QR 코드에는 얼마나 많은 정보를 담을 수 있나요? 어떤 한계가 있나요?",
          "answer": "QR 코드의 정보 용량은 콘텐츠 유형과 오류 정정 수준에 따라 다릅니다. 순수 숫자는 최대 7089글자, 알파벳-숫자 혼합은 약 4296글자, 한자 등 Unicode 문자는 약 1817글자입니다. 실제 사용에서는 스캔 속도와 성공률을 보장하기 위해 짧은 길이로 유지하는 것이 좋습니다. URL은 짧은 링크 서비스를 사용하는 것이 좋고, 긴 텍스트는 여러 개의 QR 코드로 분할하는 것을 고려하십시오."
        }
      ],
      "meta": {
        "title": "QR 코드 생성기 - 온라인에서 PNG/SVG QR 코드를 생성",
        "description": "온라인 QR 코드 생성 도구로, 크기 맞춤, 색상 및 오류 정정 수준을 지원하며, 고품질 PNG/SVG 형식의 QR 코드를 생성합니다.",
        "keywords": "QR 코드 생성기, QR 코드, QR 코드 제작"
      }
    },
    "svg-placeholder-generator": {
      "name": "SVG 플레이스홀더 이미지 생성기",
      "description": "사용자 정의 SVG 플레이스홀더 이미지 생성",
      "width_label": "너비",
      "height_label": "높이",
      "text_label": "플레이스홀더 텍스트",
      "text_placeholder": "플레이스홀더 텍스트 입력...",
      "background_color": "배경색",
      "text_color": "글자 색",
      "font_size_label": "글꼴 크기",
      "template_label": "템플릿 스타일",
      "select_template": "템플릿 스타일 선택",
      "generate_button": "플레이스홀더 이미지 생성",
      "copy_svg": "SVG 코드 복사",
      "download_svg": "SVG 파일 다운로드",
      "svg_copied": "SVG 코드가 클립보드에 복사되었습니다",
      "svg_downloaded": "SVG 파일이 다운로드되었습니다",
      "preview_title": "미리보기 효과",
      "svg_code_title": "SVG 코드",
      "templates": {
        "simple": "미니멀한 스타일",
        "gradient": "그라데이션 배경",
        "grid": "격자 배경",
        "dots": "도트 무늬 배경",
        "lines": "선 배경"
      },
      "default_text": "{width} × {height}",
      "tips_title": "사용 안내",
      "tip1_title": "크기 설정",
      "tip1_desc": "플레이스홀더 이미지의 너비와 높이를 설정하며 픽셀 단위를 지원합니다",
      "tip2_title": "텍스트 내용",
      "tip2_desc": "플레이스홀더 텍스트를 사용자 정의할 수 있으며 너비와 높이 같은 크기 변수의 동적 표시를 지원합니다",
      "tip3_title": "템플릿 선택",
      "tip3_desc": "다양한 디자인 요구를 충족하는 여러 템플릿 스타일 제공",
      "tip4_title": "내보내기 사용",
      "tip4_desc": "생성된 SVG는 웹 개발이나 디자인 초안에 바로 사용할 수 있습니다.",
      "introduction": "SVG 자리 그림 생성기는 전문 벡터 자리 그림 제작 도구로, 다양한 크기와 스타일의 SVG 자리 이미지를 빠르게 생성할 수 있습니다. SVG(확대/축소 가능한 벡터 그래픽)는 벡터 형식으로 무한 확대 시 왜곡 없이, 파일 크기가 작고 CSS 스타일 조정 등을 지원하는 이점이 있어 현대 웹 개발에 이상적인 선택입니다. 이 도구는 다양한 미리 설정된 템플릿을 제공하며, 크기, 문자, 색상 및 배경 스타일을 사용자 정의할 수 있고, 생성된 SVG 코드는 HTML에 직접 삽입하거나 디자인 초안의 자리 표시자로 사용할 수 있어 개발과 디자인 효율을 크게 향상시킵니다.",
      "features": [
        "📏 유연한 크기 제어: 50-2000픽셀 범위 내 임의 크기 설정 지원",
        "🎨 다양한 템플릿 스타일: 심플, 그라데이션, 격자, 도트 배열, 선 등 다양한 배경 템플릿",
        "✏️ 사용자 정의 텍스트 내용: 자리 표시 텍스트 및 동적 크기 변수 표시를 지원",
        "🎯 정확한 색상 제어: 전경색과 배경색을 HSL 색상 공간에서 정밀하게 조정",
        "📝 글꼴 크기 조절: 12-72픽셀 글꼴 크기 슬라이더 제어",
        "📋 원클릭 복사 기능: SVG 코드를 빠르게 클립보드에 복사",
        "💾 파일 다운로드 지원: 생성된 SVG 파일을 바로 다운로드하여 저장",
        "📱 반응형 미리보기: 실시간 미리보기, 모바일 및 데스크탑 지원"
      ],
      "faq": [
        {
          "question": "SVG 자리 그림은 전통적인 비트맷에 비해 어떤 이점이 있으며 어떤 시나리오에 적합합니까?",
          "answer": "SVG 자리 그림은 벡터 특성을 가지고 무한히 확대해도 왜곡 없이 작동하며 파일 용량이 더 작고 CSS 스타일 제어를 지원합니다. 특히 반응형 웹 디자인, 고해상도 디스플레이, 인쇄 자료, 아이콘 디자인 등의 시나리오에 적합합니다. PNG/JPG 비트맷에 비해 서로 다른 기기와 해상도에서도 선명한 표시를 유지할 수 있습니다."
        },
        {
          "question": "프로젝트에서 생성된 SVG 자리 그림을 어떻게 사용할 수 있나요?",
          "answer": "생성된 SVG 코드는 HTML에 인라인 SVG로 바로 삽입하거나 .svg 파일로 저장하고 <img> 태그나 CSS background-image로 참조할 수 있습니다. SVG는 CSS 스타일 제어를 지원하므로 CSS를 통해 색상, 크기 등의 속성을 수정할 수 있습니다. 디자인 도구에서 SVG는 자리 표시자로 Figma, Sketch 등의 디자인 소프트웨어로 가져올 수 있습니다."
        },
        {
          "question": "템플릿 스타일에는 어떤 차이가 있나요? 어떤 템플릿을 선택하면 되나요?",
          "answer": "심플 템플릿은 간결한 스타일의 프로젝트에 적합합니다; 그라데이션 템플릿은 시각적 계층감을 제공하고; 격자 템플릿은 치수 규격을 표시하기에 적합합니다; 도트 배열 템플릿은 현대적인 기술감을 갖추고 있습니다; 선 템플릿은 기하학적 스타일 디자인에 적합합니다. 선택 시 프로젝트의 디자인 스타일, 사용 시나리오 및 시각적 요구를 고려하고, 모든 템플릿은 색상을 브랜드 색상에 맞춰 커스텀할 수 있습니다."
        },
        {
          "question": "자리 표시 텍스트는 어떤 내용을 지원하나요? 동적 변수를 어떻게 사용하나요?",
          "answer": "자리 표시 텍스트는 모든 UTF-8 문자(중국어, 영어, 숫자, 기호 등)를 지원합니다. 동적 변수 {width}와 {height}는 실제 너비와 높이 값으로 자동 대체되어 표준화된 치수 표시에 편리합니다. 예를 들어 '{width}×{height}px'를 입력하면 '400×300px'로 표시되며 개발 단계의 치수 표시에 적합합니다."
        },
        {
          "question": "생성된 SVG 파일 크기는 얼마나 되나요? 성능은 어떤가요?",
          "answer": "SVG 자리 그림 파일은 매우 작아 보통 수백 바이트에서 수KB에 이르습니다. 같은 크기의 비트맷보다 훨씬 작습니다. 벡터 형식이므로 브라우저 렌더링 효율이 높고 로딩 속도가 빠릅니다. 생성된 SVG 코드 구조는 간결하고 모든 최신 브라우저와 호환되며 웹 페이지 성능에 거의 영향을 주지 않는 이상적인 자리 그림 솔루션입니다."
        }
      ],
      "meta": {
        "title": "SVG 자리 그림 생성기 - 커스텀 자리 이미지",
        "description": "온라인 SVG 자리 이미지 생성 도구로, 크기, 텍스트, 색상 및 템플릿 스타일 사용자 정의를 지원하며 빠르게 자리 이미지를 생성합니다.",
        "keywords": "SVG 자리 그림, 자리 그림 생성기, 이미지 플레이스홀더"
      }
    },
    "icon-designer": {
      "name": "아이콘 디자이너",
      "description": "텍스트, 아이콘 라이브러리 또는 커스텀 SVG를 사용하여 아이콘을 디자인하고, 색상을 사용자 정의한 뒤 다양한 크기로 내보냅니다",
      "settings_title": "아이콘 설정",
      "settings_desc": "아이콘 디자인을 사용자 정의하기",
      "content_mode": "콘텐츠 모드",
      "mode_text": "텍스트",
      "mode_icon_library": "아이콘 라이브러리",
      "mode_custom_svg": "커스텀 SVG",
      "select_icon": "아이콘 선택",
      "browse_icons": "아이콘 라이브러리 둘러보기",
      "icon_library_title": "아이콘 라이브러리",
      "icons_available": "아이콘 하나 사용 가능",
      "all_icons": "전체",
      "icon_size_label": "아이콘 크기",
      "icon_color": "아이콘 색상",
      "custom_svg_label": "사용자 정의 SVG 코드",
      "custom_svg_placeholder": "여기에 SVG 코드를 붙여넣으세요...\n\n예시(권장 viewBox는 24×24):\npath d=\\\"M12 2L2 7l10 5 10-5-10-5z\\\"\npath d=\\\"M2 17l10 5 10-5M2 12l10 5 10-5\\\"",
      "custom_svg_hint": "붙여넣으세요: SVG 경로 또는 전체 SVG 내용을 붙여넣으세요. 임의의 viewBox 크기를 지원하고, 선 아이콘과 채워진 아이콘을 자동으로 인식하며, 아이콘은 자동으로 확대/축소되고 가운데 정렬됩니다.",
      "custom_svg_color": "SVG 색상",
      "custom_svg_color_hint": "사용자 정의 SVG 색상 조절. 선 아이콘(스트로크 스타일 유지)과 채워진 아이콘을 자동으로 인식하고, 선택한 색상을 자동으로 적용합니다.",
      "svg_resources_title": "SVG 아이콘 리소스",
      "svg_resources_desc": "다음 사이트들에서 SVG 코드를 얻어 위에 붙여넣어 사용하세요",
      "visit_website": "웹사이트 방문",
      "text_label": "아이콘 문자",
      "text_hint": "아이콘으로 1~3자의 문자를 입력하세요",
      "text_hint_new": "아이콘으로 사용할 텍스트를 입력하세요(권장 1~5자, 효과 최상)",
      "shape_label": "아이콘 모양",
      "shapes": {
        "square": "정사각형",
        "circle": "원형",
        "rounded": "둥근 모서리의 사각형",
        "squircle": "초타원형"
      },
      "font_size_label": "폰트 크기",
      "font_weight_label": "폰트 두께",
      "font_weights": {
        "normal": "보통",
        "medium": "중간",
        "bold": "굵게"
      },
      "background_color": "배경 색상",
      "background_mode": "배경 모드",
      "mode_solid": "단색",
      "mode_multicolor": "다색 기하학",
      "multicolor_template": "기하학 템플릿",
      "select_template": "템플릿 선택",
      "template_categories": "템플릿 분류",
      "all_templates": "전체",
      "region_colors": "영역 색상",
      "show_text": "텍스트 표시",
      "text_color": "텍스트 색상",
      "preset_colors": "프리셋 색상",
      "random": "무작위",
      "preview_title": "실시간 미리보기",
      "preview_desc": "아이콘 디자인 효과를 실시간으로 미리보기",
      "preview_size_label": "미리보기 크기",
      "preview_mode_label": "미리보기 모드",
      "preview_mode_fit": "화면에 맞춰 표시",
      "preview_mode_actual": "실제 크기",
      "actual_size": "실제 크기",
      "scaled_to_fit": "크기에 맞게 조정됨",
      "scroll_to_view": "전체 크기를 스크롤로 확인",
      "size_preview": "다중 크기 미리보기",
      "copy_svg": "SVG 복사",
      "download_ico": "ICO 다운로드(다중 사이즈)",
      "export_title": "내보내기 옵션",
      "export_desc": "다양한 크기와 형식으로 아이콘을 다운로드하세요",
      "ico_download_title": "ICO 파일 다운로드(ZIP 압축 파일)",
      "ico_download_desc": "선택한 각 크기마다 하나의 ICO 파일로 묶어 다운로드",
      "download_selected_ico": "선택한 크기 다운로드(ICO)",
      "download_standard_ico": "표준 크기 다운로드(ICO)",
      "standard_ico_desc": "표준 6가지 크기, 6개의 ICO 파일",
      "ico_includes": "생성됩니다",
      "ico_files": "ICO 파일 개수",
      "ico_size_too_large": "ICO에 사용할 256px 이하의 최소 하나의 크기를 선택하세요",
      "individual_sizes": "단일 크기로 내보내기",
      "batch_download_all": "모든 크기를 일괄 다운로드",
      "batch_download_all_desc": "모든 크기를 한 번에 다운로드하고 ZIP 파일로 패키징",
      "download_all_formats": "전체 다운로드(SVG + PNG)",
      "only": "오직",
      "zip_includes": "ZIP 포함",
      "sizes": "다양한 크기",
      "formats": "다양한 형식",
      "preview_and_download": "미리보기 및 다운로드",
      "batch_download_selected": "선택한 크기 일괄 다운로드",
      "batch_download_selected_desc": "선택한 크기만 다운로드하여 ZIP 파일로 묶기",
      "selected_count": "선택됨",
      "select_all": "전체 선택",
      "deselect_all": "전체 선택 해제",
      "click_to_select": "선택/해제 클릭",
      "click_to_preview": "실제 크기로 미리보기",
      "click_preview": "미리보기 클릭",
      "no_size_selected": "적어도 하나의 크기를 선택해 주세요",
      "svg_code_title": "SVG 코드",
      "svg_code_desc": "생성된 SVG 코드를 복사하여 사용",
      "tips_title": "디자인 팁",
      "tip1_title": "문자 선택",
      "tip1_desc": "1~3자의 글자를 사용하는 것이 가장 좋습니다. 한 글자는 사용자 아바타나 앱 아이콘에 매우 적합합니다.",
      "tip2_title": "색상 대비",
      "tip2_desc": "텍스트와 배경 색상 간에 충분한 대비를 확보하여 가시성과 접근성을 높이세요.",
      "tip3_title": "도형 선택",
      "tip3_desc": "원형과 초타원은 사용자 프로필 사진에 적합하고, 모서리가 둥근 사각형은 앱 아이콘에 적합합니다.",
      "tip4_title": "일괄 다운로드",
      "tip4_desc": "일괄 다운로드 기능을 사용하면 모든 사이즈를 한 번에 받아 ZIP 파일로 묶습니다. SVG와 PNG 두 가지 형식을 포함하며, 폴더별로 정리됩니다.",
      "introduction": "문자 아이콘 디자이너는 간단하고 우아한 문자 아이콘을 생성하기 위한 전문 도구입니다. 사용자 아바타, 앱 아이콘, 브랜드 로고 및 자리 표시자 이미지에 매우 적합합니다. 이 도구는 SVG 형식을 지원하며 무한한 확장성, 커스텀 색상, 다양한 도형을 갖추고 있으며 다양한 크기로 내보낼 수 있습니다. 디자인 소프트웨어가 없어도 몇 초 만에 전문 아이콘을 생성할 수 있습니다.",
      "features": [
        "✏️ 사용자 정의 텍스트: 1~3자의 개인화 아이콘 지원",
        "🎨 다양한 도형 옵션: 정사각형, 원형, 모서리 둥근 사각형 및 초타원형",
        "🌈 완전한 색상 커스터마이즈: 배경 색상과 글자 색상을 자유롭게 선택하고 미리 설정된 팔레트를 사용할 수 있습니다.",
        "📏 유연한 글꼴 제어: 글꼴 크기와 두께를 조절하여 완벽한 모양을 구현합니다.",
        "👁️ 실시간 미리보기: 16px에서 128px까지 다양한 크기의 아이콘을 즉시 미리보기",
        "📦 일괄 내보내기: 한 번에 7가지 일반 크기로 내보내기(16px에서 1024px까지)",
        "💾 이중 포맷 지원: 필요에 따라 SVG 또는 PNG 형식으로 내보내기",
        "🎲 무작위 색상 생성기: 무작위 색상 조합으로 빠르게 아이디어를 얻으세요."
      ],
      "faq": [
        {
          "question": "SVG 형식 아이콘의 장점은 무엇인가요? 어떤 경우에 PNG를 사용해야 하나요?",
          "answer": "SVG 아이콘은 벡터이며 무한히 확대 축소해도 왜곡이 없고 파일 용량이 더 작으며 CSS 스타일을 지원합니다. 반응형 웹 디자인과 현대 애플리케이션에 매우 적합합니다. 고정된 특정 크기의 아이콘이 필요하거나 SVG 지원이 제한된 대상 환경에서는 PNG 형식을 사용하세요."
        },
        {
          "question": "내 아이콘에 맞는 모양은 어떻게 선택하나요?",
          "answer": "원형과 초타원형 모양이 사용자 프로필 사진에 가장 적합합니다. 모서리 둥근 사각형은 앱 아이콘과 로고에 적합합니다. 정사각형은 더 공식적이고 전문적인 외관을 제공합니다. 선택할 때 사용 환경과 브랜드 스타일을 고려하십시오."
        },
        {
          "question": "다양한 용도에 따라 어떤 크기로 내보내야 하나요?",
          "answer": "웹용 프로필 사진: 64px, 128px, 256px. 앱 아이콘: 128px, 256px, 512px, 1024px. 사이트 아이콘: 16px, 32px. 소셜 미디어: 256px, 512px. 이 도구를 사용하면 일반적으로 필요한 모든 크기를 한 번에 내보낼 수 있습니다."
        },
        {
          "question": "접근성을 높이려면 어떻게 적절한 색상 대비를 보장합니까?",
          "answer": "미리 설정된 색상 조합을 사용하면 설계 시 이미 충분한 대비를 고려했습니다. 사용자 정의 색상의 경우 텍스트와 배경 사이에 충분한 대비가 있는지 확인하세요. 밝은 배경에 어두운 글자나 어두운 배경에 밝은 글자가 보통 최적의 효과를 냅니다."
        },
        {
          "question": "생성된 아이콘을 상업적으로 사용할 수 있나요?",
          "answer": "네! 이 도구로 생성된 모든 아이콘은 귀하의 소유이며 자유롭게 사용할 수 있습니다. 상업적 용도 포함. 워터마크, 서명 요구 또는 사용 제약이 없습니다."
        }
      ],
      "meta": {
        "title": "문자 아이콘 디자이너 - 커스텀 SVG 아이콘 생성",
        "description": "온라인 문자 아이콘 디자인 도구로 문자, 색상 및 모양을 사용해 맞춤 SVG 아이콘을 만들고, 아바타와 앱 아이콘용으로 다양한 크기로 내보냅니다.",
        "keywords": "아이콘 디자이너, 문자 아이콘, 아바타 생성기"
      }
    },
    "hmac-generator": {
      "name": "HMAC 생성기",
      "description": "HMAC 메시지 인증 코드 생성 도구",
      "input_title": "입력 구성",
      "input_desc": "HMAC 생성 매개변수 설정",
      "data_label": "메시지 데이터",
      "data_placeholder": "생성할 HMAC의 메시지 데이터를 입력하세요...",
      "key_label": "키",
      "key_placeholder": "HMAC 키를 입력하세요...",
      "generate_key": "랜덤 키 생성",
      "algorithm_label": "알고리즘",
      "select_algorithm": "HMAC 알고리즘 선택",
      "format_label": "출력 형식",
      "select_format": "출력 형식 선택",
      "generate": "HMAC 생성",
      "verify": "HMAC 검증",
      "output_title": "HMAC 결과",
      "output_desc": "생성된 HMAC 값",
      "output_placeholder": "생성된 HMAC가 여기에 표시됩니다...",
      "hmac_result": "HMAC 값",
      "algorithm_used": "알고리즘 사용",
      "output_format": "출력 형식",
      "hash_length": "해시 길이",
      "characters": "문자",
      "missing_input_key": "생성할 메시지 데이터와 키를 입력하세요",
      "missing_verification_data": "전체 검증 데이터를 입력하세요",
      "tips_title": "사용 설명",
      "tip1_title": "HMAC 원리",
      "tip1_desc": "HMAC는 해시 함수와 비밀 키를 기반으로 하여 메시지 무결성과 인증을 제공합니다.",
      "tip2_title": "알고리즘 선택",
      "tip2_desc": "SHA-256 이상 강도의 알고리즘 사용을 권장합니다.",
      "tip3_title": "키 보안",
      "tip3_desc": "HMAC의 보안은 비밀 키의 기밀성에 의존합니다.",
      "tip4_title": "적용 시나리오",
      "tip4_desc": "일반적으로 API 서명, JWT 검증, 데이터 무결성 검사에 사용됩니다.",
      "introduction": "HMAC 생성기는 해시 기반의 메시지 인증 코드(Hash-based Message Authentication Code) 전문 생성 도구입니다. HMAC는 암호 해시 함수와 비밀 키를 결합하여 데이터의 무결성 검증과 신원 인증을 제공합니다. RFC 2104 표준에서 정의된 보안 알고리즘으로서 HMAC은 API 보안 인증, JWT 토큰 검증, 디지털 서명 등의 핵심 보안 시나리오에 널리 사용됩니다. 본 도구는 다양한 보안 해시 알고리즘을 지원하며, 유연한 출력 형식을 제공하고, 모든 계산 과정은 로컬에서 이루어져 키와 데이터의 보안을 보장합니다.",
      "features": [
        "🔐 SHA-1、SHA-256、SHA-384、SHA-512 등 다양한 보안 해시 알고리즘을 지원합니다",
        "🔑 랜덤 키 생성 기능으로 고강도 암호 키를 제공합니다",
        "📝 다양한 출력 형식 지원: 16진수, Base64, 이진 표시",
        "⚡ 실시간 HMAC 계산, 입력 즉시 인증 코드를 생성합니다",
        "🔍 HMAC 검증 기능, 메시지 무결성 검증을 지원합니다",
        "📋 결과를 한 번에 복사하여 개발 프로세스에 쉽게 통합합니다",
        "🔒 로컬 계산으로 프라이버시를 보호하며, 키와 데이터는 브라우저를 떠나지 않습니다",
        "📱 반응형 인터페이스 디자인으로 모바일과 데스크톱에서 모두 작동합니다"
      ],
      "faq": [
        {
          "question": "HMAC란 무엇입니까? 일반 해시 함수와의 차이는 무엇입니까?",
          "answer": "HMAC(Hash-based Message Authentication Code)은 해시 함수 기반의 메시지 인증 코드로, 암호 해시 함수와 비밀 키를 결합합니다. 일반 해시 함수와 달리 HMAC은 계산에 키가 필요하며, 메시지 무결성 검증과 발신자 인증을 제공합니다. 공격자가 원래 메시지와 HMAC 값을 알고 있어도 키가 없으면 유효한 HMAC를 위조할 수 없습니다."
        },
        {
          "question": "어떤 해시 알고리즘이 더 안전합니까? SHA-1과 SHA-256 중 어떤 것이 더 안전합니까?",
          "answer": "SHA-256 이상 강도의 알고리즘 사용을 강력히 권장합니다. SHA-1은 충돌 취약점이 입증되어 더 이상 안전하다고 간주되지 않습니다. SHA-256은 256비트 출력을 제공하여 더 높은 보안성과 충돌 저항력을 가집니다. 보안 요구가 높은 애플리케이션의 경우 SHA-384 또는 SHA-512를 선택할 수 있습니다. 대부분의 최신 API 및 보안 표준은 최소한 SHA-256 사용을 요구합니다."
        },
        {
          "question": "HMAC 키는 어떻게 생성하고 관리해야 합니까?",
          "answer": "HMAC 키는 무작위로 생성되어야 하며, 선택한 해시 함수의 출력 길이 이상이어야 합니다(SHA-256의 경우 32바이트). 저희 도구는 안전한 무작위 키 생성 기능을 제공합니다. 실제 응용에서 키는 안전하게 저장하고 정기적으로 순환시키며, 전문 키 관리 시스템을 사용하고 안전한 채널을 통해 배포해야 합니다. 결코 코드에 하드코딩하거나 평문으로 키를 전송해선 안 됩니다."
        },
        {
          "question": "API 인증에서 HMAC은 어떻게 사용됩니까?",
          "answer": "API 인증에서 일반적으로 요청의 핵심 정보(예: HTTP 메서드, URL, 타임스탬프, 요청 본문)를 문자열로 결합한 다음 공유 키를 사용해 HMAC 서명을 생성합니다. 서버가 요청을 수신하면 동일한 방법으로 HMAC를 계산하고 제공된 서명을 비교합니다. 이것은 요청이 변조되지 않았으며 권한이 부여된 발신자로부터 왔음을 보장합니다. 일반적인 구현으로는 AWS 서명, GitHub Webhook, OAuth 등이 있습니다."
        },
        {
          "question": "HMAC의 정확성을 어떻게 검증합니까?",
          "answer": "HMAC를 검증하려면 결과를 재계산하고 비교해야 합니다. 동일한 메시지, 키 및 알고리즘으로 HMAC를 다시 생성한 다음 원래의 HMAC와 비교합니다. 시간 기반 공격을 피하기 위해 상수 시간 비교 알고리즘을 사용하는 것이 중요합니다. 우리의 도구는 검증 기능을 제공하여 원시 데이터, 키 및 기대되는 HMAC 값을 입력해 검증하고 데이터 무결성을 보장합니다."
        }
      ],
      "meta": {
        "title": "HMAC 생성기 - API 서명 및 메시지 인증",
        "description": "온라인 HMAC 생성 도구로 다양한 해시 알고리즘을 지원하며 API 서명과 메시지 인증 코드(MAC)를 생성하여 데이터 무결성과 인증을 보장합니다.",
        "keywords": "HMAC 생성기, API 서명, 메시지 인증"
      }
    },
    "ip-lookup": {
      "name": "IP 주소 조회",
      "description": "IP 주소의 지리적 위치와 네트워크 정보를 조회합니다.",
      "input_title": "IP 주소 입력",
      "output_title": "조회 결과",
      "placeholder": "IP 주소를 입력해주세요(예: 8.8.8.8)",
      "output_placeholder": "조회 결과가 여기에 표시됩니다.",
      "current_ip": "귀하의 IP 주소",
      "query_button": "조회",
      "auto_detect": "자동 감지",
      "invalid_ip": "유효하지 않은 IP 주소 형식",
      "query_failed": "조회에 실패했습니다. 나중에 다시 시도해 주세요.",
      "querying": "조회 중...",
      "rate_limited": "조회가 너무 자주 발생했습니다. 나중에 다시 시도해 주세요.",
      "network_error": "네트워크 연결 오류",
      "info": {
        "basic": "기본 정보",
        "location": "지리적 위치",
        "network": "네트워크 정보",
        "security": "보안 정보",
        "ip_address": "IP 주소",
        "country": "국가",
        "region": "지역",
        "city": "도시",
        "postal_code": "우편번호",
        "latitude": "위도",
        "longitude": "경도",
        "timezone": "시간대",
        "isp": "인터넷 서비스 제공자",
        "organization": "조직",
        "as_number": "AS 번호",
        "proxy": "프록시 서버",
        "mobile": "모바일 네트워크",
        "yes": "예",
        "no": "아니오"
      },
      "actions": {
        "copy_ip": "IP 주소 복사",
        "copy_all": "모든 정보 복사",
        "export_json": "JSON 내보내기",
        "clear_results": "결과 지우기"
      },
      "introduction": "IP 주소 조회 도구는 전문적인 네트워크 지리적 위치 분석 도구로, 임의의 IP 주소에 대한 상세 정보를 신속하게 얻을 수 있습니다. 지리적 위치, 인터넷 서비스 제공자, 표준시 정보, 프록시 탐지 등 다차원 데이터를 포함합니다. 네트워크 보안 분석, 방문자 통계, 지리적 제한, 사기 탐지 등 다양한 시나리오에 널리 활용됩니다. IPv4 및 IPv6 주소 조회를 지원하며, 정확한 지리적 위치와 네트워크 토폴로지 정보를 제공합니다. 네트워크 관리자와 개발자의 필수 도구입니다.",
      "features": [
        "🌍 전 세계 IP 주소 데이터베이스, IPv4 및 IPv6를 포함합니다",
        "📍 정확한 지리적 위치, 국가·지역·도시 정보를 포함합니다.",
        "🏢 상세 ISP 정보, 인터넷 서비스 제공자와 조직을 표시합니다.",
        "🕒 시간대 정보 조회, 전 세계 시간대 표시를 지원합니다.",
        "🛡️ 프록시 및 VPN 탐지, 익명 네트워크를 식별합니다.",
        "📱 모바일 네트워크 식별, 통신사와 네트워크 유형을 구분합니다.",
        "⚡ 실시간 조회 응답, 밀리초 단위 데이터 반환",
        "📋 한 번에 결과를 복사하고, 다양한 형식으로 내보내기를 지원합니다."
      ],
      "faq": [
        {
          "question": "IP 주소 조회의 정확성은 어떻습니까?",
          "answer": "IP 지리 위치의 정확도는 데이터베이스 품질과 IP 할당 방식에 따라 달라집니다: 1) 국가 수준의 정확도는 보통 95% 이상; 2) 도시 수준의 정확도는 약 70-80%; 3) 기업 전용 회선 IP 위치지정이 더 정확합니다; 4) 모바일 네트워크 IP에는 편차가 있을 수 있습니다; 5) VPN 및 프록시 IP는 실제 위치가 아닌 서버 위치를 표시합니다. 우리는 데이터 정확성을 보장하기 위해 여러 공신력 있는 데이터 소스를 사용합니다."
        },
        {
          "question": "일부 IP 조회 결과가 정확하지 않게 표시되는 이유는 무엇입니까?",
          "answer": "IP 위치지정이 정확하지 않은 일반적인 원인: 1) VPN 또는 프록시 서비스 사용; 2) 이동통신망의 동적 IP 할당; 3) 기업 내부망이 NAT를 통해 접근; 4) 통신사의 IP 주소 풀의 지역 간 할당; 5) 데이터베이스 업데이트 지연. 중요한 애플리케이션의 경우 다른 위치확인 방법과 함께 검증을 권장합니다."
        },
        {
          "question": "IP 주소를 조회할 때 제 개인정보가 노출되나요?",
          "answer": "저희의 IP 조회 도구를 사용하는 것은 안전합니까: 1) 조회 과정은 완전히 익명이며 사용자 정보를 기록하지 않습니다; 2) 조회 이력과 결과 데이터를 저장하지 않습니다; 3) HTTPS 암호화 전송을 지원합니다; 4) 공개된 지리 및 네트워크 정보만 반환합니다; 5) 개인 프라이버시 데이터는 포함되지 않습니다. 다만 합리적으로 사용하고 타인의 프라이버시를 존중하시기 바랍니다."
        },
        {
          "question": "IP가 프록시나 VPN을 사용 중인지 어떻게 감지합니까?",
          "answer": "프록시와 VPN 감지 원리: 1) 알려진 프록시 서버 IP 데이터베이스를 확인; 2) 네트워크 지연 시간과 라우팅 경로의 이상 징후를 분석; 3) 익명화 서비스의 특징을 탐지; 4) IP 소유지와 실제 방문 지리 위치를 비교; 5) 상용 VPN 서비스 제공자를 식별합니다. 저희 도구는 결과에 탐지된 프록시 상태를 표시합니다."
        },
        {
          "question": "IPv6 주소로도 지리 위치를 확인할 수 있나요?",
          "answer": "IPv6 주소 조회를 지원하지만 약간의 차이가 있습니다: 1) IPv6 지리 데이터베이스가 비교적 새로워 커버리지가 지속 확장 중; 2) 위치 정확도가 IPv4보다 다소 낮을 수 있음; 3) 많은 IPv6 주소가 아직 배정되거나 사용되지 않음; 4) 기업 및 교육망의 IPv6 배정이 더 규범적임; 5) IPv6 보급과 함께 데이터 정확성이 지속 향상됩니다. 활성 IPv6 주소를 우선 조회하는 것을 권장합니다."
        }
      ],
      "meta": {
        "title": "IP 주소 조회 도구 - 지리 위치와 네트워크 정보 조회",
        "description": "온라인 IP 주소 조회 도구로 IP 주소의 지리 위치, ISP 정보, 시차 등 상세 정보를 제공합니다.",
        "keywords": "IP 조회, IP 주소, 지리 위치"
      }
    },
    "time-converter": {
      "name": "밀리초 시간 변환기",
      "description": "밀리초 타임스탬프와 yyyy-MM-dd HH:mm:ss 문자열 사이를 변환합니다.",
      "from_milliseconds_title": "밀리초 → 날짜 문자열",
      "from_milliseconds_description": "밀리초 값을 입력하면 포맷된 로컬 시간 문자열을 확인할 수 있습니다.",
      "milliseconds_input_label": "밀리초 값",
      "milliseconds_placeholder": "예시: 1735689600000",
      "milliseconds_hint": "양의 정수와 음수 정수를 지원하며 로컬 타임존에 따라 해석합니다.",
      "use_current_milliseconds": "현재 밀리초 값을 사용합니다.",
      "invalid_milliseconds": "유효한 밀리초 값을 입력하십시오.",
      "formatted_time_label": "형식화된 시간(yyyy-MM-dd HH:mm:ss)",
      "from_string_title": "날짜 문자열 → 밀리초",
      "from_string_description": "yyyy-MM-dd HH:mm:ss 형식으로 문자열을 입력하면 밀리초 타임스탬프로 변환됩니다.",
      "string_input_label": "날짜 문자열",
      "string_hint": "24시간 표기를 사용합니다. 예: 2025-01-01 08:30:45.",
      "use_current_string": "현재 시간 문자열을 입력하십시오.",
      "invalid_string": "날짜 문자열은 반드시 yyyy-MM-dd HH:mm:ss 형식에 부합해야 하며 실제 시간이어야 합니다.",
      "milliseconds_output_label": "밀리초 결과",
      "normalized_label": "표준화",
      "quick_reference_title": "빠른 참조",
      "quick_reference_description": "로그나 스크립트에 활용하기 위해 현재 시간의 문자열과 밀리초 값을 빠르게 얻을 수 있습니다.",
      "current_time_label": "현재 시간 문자열",
      "current_milliseconds_label": "현재 밀리초 값",
      "copy_current_string": "시간 문자열 복사",
      "copy_current_milliseconds": "밀리초 값 복사",
      "fill_with_latest": "최신 시간으로 채워 넣기",
      "introduction": "밀리초 시간 변환기는 원시 타임스탬프와 읽기 가능한 날짜 사이를 신속하게 전환하며, 일관된 형식을 유지합니다. 로그 확인, API 디버깅 및 자동화 스크립트에 적합합니다.",
      "features": [
        "🔁 밀리초 값과 yyyy-MM-dd HH:mm:ss 문자열의 양방향 변환。",
        "입력 시 즉시 검증되어 형식 오류로 인한 파싱 실패를 방지합니다.",
        "현재 시간을 한 번에 채우고 복사하여 일상 작업의 효율성을 높입니다.",
        "음수 밀리초 값을 지원하여 1970년 이전의 날짜를 확인할 수 있습니다.",
        "브라우저의 로컬 타임존과 일치하여 보이는 값이 그대로 반영됩니다."
      ],
      "faq": [
        {
          "question": "변환에 사용되는 시간대는 무엇입니까?",
          "answer": "모든 변환은 브라우저가 위치한 로컬 시간대를 기준으로 합니다. 문자열로 표시되는 시간은 로컬 시간이며, 밀리초 값은 JavaScript Date 객체와 일치합니다."
        },
        {
          "question": "날짜 문자열에 밀리초 부분을 포함할 수 있나요?",
          "answer": "현재 버전은 초 단위 형식만 지원합니다. 밀리초 정밀도가 필요한 경우, 밀리초 입력란에서 처리하면 문자열은 초 정밀도로 표시됩니다."
        }
      ],
      "meta": {
        "title": "타임스탬프 변환기 - 밀리초와 날짜 문자열 간 상호 변환",
        "description": "무료의 온라인 도구로, 밀리초 타임스탬프를 신속하게 yyyy-MM-dd HH:mm:ss 문자열로 변환하고, 역변환 및 검증을 지원합니다.",
        "keywords": "타임스탬프 변환, 밀리초 변환, 시간 도구"
      }
    },
    "cron-expression-parser": {
      "name": "크론 표현식 해석기",
      "description": "크론 구문을 검증하고 다가올 실행 시간을 미리 확인합니다.",
      "format_title": "크론 표현식 형식 설명",
      "format_description": "크론 표현식의 기본 구조와 특수 문자 의미를 이해합니다.",
      "format": {
        "minute_desc": "분 (0 - 59)",
        "hour_desc": "시 (0 - 23)",
        "day_desc": "일 (1 - 31)",
        "month_desc": "월 (1 - 12) 또는 JAN, FEB ...",
        "weekday_desc": "주 (0 - 6, 일요일=0) 또는 SUN, MON ...",
        "symbols": {
          "wildcard": "임의 값",
          "range": "수치 범위 (예: 1-10)",
          "list": "수치 목록 (예: 1,10)",
          "step": "증분 값 (예: */10)"
        }
      },
      "input_title": "크론 표현식",
      "input_description": "표준 5단 크론 표현식을 입력하여 각 필드를 해석하고 향후 실행 시간을 확인합니다.",
      "expression_label": "표현식",
      "expression_hint": "분, 시, 일, 월, 주 다섯 단 포맷을 지원하며 JAN, MON 등 영어 이름을 사용할 수 있습니다.",
      "presets": {
        "workday_morning": "평일 오전 9시",
        "every_fifteen_minutes": "매 15분마다"
      },
      "preview_count_label": "미리보기 수량 (1-20)",
      "current_time_label": "참고 시간",
      "structure_title": "필드 해석",
      "structure_description": "각 필드가 확장된 후의 구체적인 값을 확인합니다.",
      "table": {
        "field": "필드",
        "raw": "원시 값",
        "values": "값"
      },
      "fields": {
        "minute": "분",
        "hour": "시",
        "day_of_month": "날짜",
        "month": "월",
        "day_of_week": "요일",
        "any": "임의"
      },
      "errors": {
        "empty": "크론 표현식을 입력한 다음 해석합니다.",
        "invalid_field_count": "크론 표현식은 5단(분, 시, 일, 월, 요일)을 포함해야 합니다.",
        "invalid_field": "필드 {field}에 지원되지 않는 구문이나 범위를 벗어난 값이 포함되어 있습니다."
      },
      "upcoming_title": "향후 실행 시간",
      "upcoming_description": "현재 시간대와 결합하여 앞으로 몇 차례의 실행 시간을 미리 봅니다.",
      "upcoming_placeholder": "실행 시간을 보려면 유효한 표현식을 입력하십시오.",
      "upcoming_empty": "향후 1년 이내에 일치하는 실행 시간이 없으니 표현식을 조정해 보십시오.",
      "occurrence_index": "제 {index}번째",
      "introduction": "크론 표현식 해석기는 개발자가 실행 계획을 빠르게 검증하고 각 필드의 확장 결과를 이해하며 다가올 실행 시간을 미리 확인할 수 있도록 돕습니다. 이 도구는 일반적인 UNIX 스타일 구문과 영어 월 이름, 요일 이름을 지원하여 자동화 디버깅을 더 효율적이고 신뢰할 수 있게 만듭니다.",
      "features": [
        "🧭 실시간으로 검증하고 오류 필드를 명확하게 안내합니다.",
        "📅 직관적으로 분, 시, 일, 월, 요일의 실제 값을 표시합니다.",
        "⏱ 최대 20개의 미래 실행 시간을 생성하며 로컬 타임존을 자동으로 사용합니다.",
        "자주 사용되는 작업 예약 프리셋이 내장되어 있어 빠르게 참고 예시로 전환합니다.",
        "숫자와 JAN-DEC, MON-SUN 등 영어 이름을 동시에 지원합니다."
      ],
      "faq": [
        {
          "question": "도구는 어떤 크론 포맷을 지원합니까?",
          "answer": "해석기는 전통적인 다섯 단 UNIX Cron 포맷(분, 시, 일, 월, 요일)을 따릅니다. 현재 초나 Quartz 확장 필드를 포함하는 표현식은 지원하지 않습니다."
        },
        {
          "question": "날짜 및 요일 필드가 어떻게 함께 작용합니까?",
          "answer": "두 필드가 모두 구체적인 값일 때(* 또는 ?가 아닌 경우), 날짜나 요일 중 하나가 일치하면 실행됩니다. 이는 대부분의 Linux Cron 동작과 일치합니다. 특정 필드를 무시하려면 ?를 사용할 수 있습니다."
        }
      ],
      "meta": {
        "title": "Cron 표현식 해석기 - 온라인 검증 테스트",
        "description": "무료 Cron 표현식 온라인 해석 도구로, 구문 검사, 필드 확장 및 향후 실행 시간 미리보기를 지원합니다.",
        "keywords": "Cron 표현식, 작업 스케줄링, Cron 검증"
      }
    },
    "curl-converter": {
      "name": "cURL 명령 변환기",
      "description": "cURL 명령을 다양한 프로그래밍 언어의 코드로 변환하고 요청을 직접 테스트할 수 있습니다.",
      "input_title": "cURL 명령 입력",
      "input_desc": "cURL 명령 붙여넣기 또는 입력",
      "input_placeholder": "cURL 명령을 입력해 주세요... 예: curl -X POST https://api.example.com/users -H 'Content-Type: application/json' -d '{\"name\":\"John\",\"email\":\"john@example.com\"}'",
      "output_title": "생성된 코드",
      "output_desc": "변환된 코드는 여기에서 표시됩니다",
      "output_placeholder": "변환된 코드는 여기에서 표시됩니다...",
      "convert_button": "변환 코드",
      "test_button": "테스트 요청",
      "test_result_title": "요청 결과",
      "test_result_desc": "API 요청의 응답 결과",
      "language_label": "목표 언어",
      "invalid_command": "잘못된 cURL 명령",
      "conversion_failed": "변환 실패, 명령 형식을 확인하세요",
      "test_failed": "요청 실패",
      "tips_title": "사용 방법",
      "tip1_title": "명령 형식",
      "tip1_desc": "표준 cURL 명령을 포함한 다양한 매개변수와 옵션을 지원합니다",
      "tip2_title": "지원되는 매개변수",
      "tip2_desc": "일반적으로 사용되는 매개변수로 -X/--request, -H/--header, -d/--data/--data-raw 등",
      "tip3_title": "다국어 지원",
      "tip3_desc": "JavaScript, Python, Node.js, PHP, Go 등으로의 변환을 지원합니다",
      "tip4_title": "온라인 테스트",
      "tip4_desc": "서버 프록시를 통해 API 요청을 테스트하여 CORS 제한 없이 전체 응답을 확인합니다",
      "introduction": "cURL 명령 변환기는 개발자를 위해 설계된 실용 도구로, cURL 명령을 다양한 프로그래밍 언어의 HTTP 요청 코드로 빠르게 변환합니다. JavaScript Fetch, Python Requests, Node.js Axios, PHP cURL, Go net/http 등의 주요 언어와 프레임워크를 지원합니다. 코드 생성뿐만 아니라 브라우저에서 직접 API 요청을 테스트하고 응답 결과를 확인할 수 있습니다. API 디버깅, 문서 작성 또는 코드 마이그레이션에 이 도구를 사용하면 개발 효율이 크게 향상됩니다.",
      "features": [
        "🔄 지능형 CURL 명령 해석, 다양한 매개변수 형식 지원",
        "💻 다수의 프로그래밍 언어 지원: JavaScript, Python, Node.js, PHP, Go",
        "🎯 HTTP 메서드, 요청 헤더, 요청 본문 등 파라미터 자동 인식",
        "⚡ 실시간 변환, 즉시 사용 가능한 코드 생성",
        "🧪 서버 프록시를 통해 CORS 제한 없이 내장된 요청 테스트 기능",
        "📋 생성된 코드를 한 번의 클릭으로 클립보드에 복사",
        "💾 해당 언어의 소스 파일로 다운로드 지원",
        "🔒 로컬에서 처리되어 API 키와 데이터의 보안을 보장"
      ],
      "faq": [
        {
          "question": "왜 cURL 변환 도구가 필요합니까?",
          "answer": "API 개발 및 테스트에서 많은 문서와 도구(예: Postman)가 cURL 명령 예제를 제공합니다. 이 도구는 이러한 cURL 명령을 빠르게 실제 프로젝트에서 사용하는 프로그래밍 언어 코드로 변환하여 수동 작성으로 인한 오류를 줄이고 효율을 높일 수 있습니다. 제3자 API를 빠르게 통합해야 하는 상황에 특히 적합합니다."
        },
        {
          "question": "도구는 어떤 cURL 매개변수를 지원합니까?",
          "answer": "도구는 일반적으로 사용되는 cURL 매개변수(예: -X/--request(HTTP 메서드), -H/--header(요청 헤더), -d/--data/--data-raw(요청 본문), URL 등)를 지원합니다. 자주 쓰이지 않는 매개변수는 변환된 코드 기반에서 수동으로 조정할 수 있습니다."
        },
        {
          "question": "생성된 코드를 바로 사용할 수 있나요?",
          "answer": "생성된 코드는 각 언어의 표준 관행을 따르며 대부분의 경우 바로 사용할 수 있습니다. 다만 실제 프로젝트 요구에 따라 적절히 조정하는 것이 좋습니다: 1) API 엔드포인트와 매개변수 검증; 2) 오류 처리 로직 추가; 3) 필요에 따라 타임아웃 설정 조정; 4) 응답 데이터 형식 처리; 5) 필요한 환경 변수 및 구성 추가."
        },
        {
          "question": "민감한 정보를 포함하는 cURL 명령을 어떻게 처리합니까?",
          "answer": "모든 변환 작업은 브라우저에서 로컬로 수행되며 명령 내용은 어느 서버에도 업로드되지 않습니다. 하지만 다음을 권장합니다: 1) 변환 전 민감한 API 키와 토큰 제거 또는 교체; 2) 환경 변수로 민감한 구성을 관리; 3) 코드에 비밀번호와 키를 하드코딩하지 않기; 4) 생성된 코드를 공개 저장소에 바로 제출하지 않기; 5) 프로젝트 구성 파일로 API 자격증명을 관리."
        },
        {
          "question": "테스트 기능에 어떤 제한이 있나요?",
          "answer": "테스트 기능은 서버 측 프록시를 통해 요청을 전송하여 CORS 문제를 해결했습니다. 다만 아래 주의사항이 있습니다: 1) 일부 특별한 인증이 필요한 API는 올바른 인증 정보를 구성해야 할 수 있습니다; 2) 요청 타임아웃은 기본값이며 매우 큰 응답은 더 긴 시간이 필요할 수 있습니다; 3) 테스트 기능은 API 접속 가능성과 응답 형식을 빠르게 검증하는 데 적합; 4) 프로덕션 환경의 상세한 테스트는 Postman이나 Insomnia 같은 전문 도구를 사용하는 것이 좋습니다."
        }
      ],
      "meta": {
        "title": "cURL 명령 변환기 - JS/Python/PHP 등으로",
        "description": "온라인 cURL 명령 변환 도구로, cURL 명령을 JavaScript, Python, Node.js, PHP, Go 등 언어의 코드로 빠르게 변환하고 온라인 테스트를 지원합니다.",
        "keywords": "cURL 변환, API 테스트, 코드 생성"
      }
    },
    "color-converter": {
      "name": "색상 변환기",
      "description": "HEX, RGB, HSL 및 CSS 색상 이름 간 변환",
      "input_title": "색상 입력",
      "input_desc": "임의 형식의 색상 값을 입력",
      "input_placeholder": "색상 값을 입력합니다(예: #FF5733, rgb(255, 87, 51), hsl(9, 100%, 60%) 또는 red)",
      "output_title": "변환 결과",
      "color_preview": "색상 미리보기",
      "hex_format": "HEX 형식",
      "rgb_format": "RGB 형식",
      "hsl_format": "HSL 형식",
      "css_name": "CSS 색상 이름",
      "invalid_color": "유효하지 않은 색상 값",
      "no_css_name": "해당하는 CSS 색상 이름이 없습니다",
      "tips_title": "사용 방법",
      "tip1_title": "지원 형식",
      "tip1_desc": "HEX(#RGB, #RRGGBB), RGB, HSL 및 CSS 색상 이름 지원",
      "tip2_title": "자동 인식",
      "tip2_desc": "입력된 색상 형식을 자동 인식하고 다른 형식으로 변환",
      "tip3_title": "실시간 미리보기",
      "tip3_desc": "실시간으로 색상 미리보기와 모든 형식의 변환 결과를 표시",
      "tip4_title": "빠른 복사",
      "tip4_desc": "복사 버튼을 클릭해 다양한 형식의 색상 값을 빠르게 복사",
      "introduction": "색상 변환기는 전문적인 색상 형식 변환 도구로, HEX, RGB, HSL 및 CSS 색상 이름 간 자유롭게 변환할 수 있습니다. 웹 디자이너, 프런트 엔드 개발자 또는 UI/UX 디자이너 여부에 관계없이 필요한 형식의 색상 값을 빠르게 얻을 수 있습니다. 이 도구는 실시간 색상 미리보기와 다양한 형식의 원클릭 복사를 지원하여 디자인 및 개발 효율성을 크게 높입니다.",
      "features": [
        "🎨 HEX, RGB, HSL, CSS 색상 이름의 다양한 형식 지원",
        "🔄 입력 형식을 스마트하게 인식하고 다른 형식으로 자동 변환",
        "👁️ 실시간 색상 미리보기로 색상 효과를 직관적으로 확인",
        "📋 다양한 형식의 색상 값을 한 번에 복사",
        "⚡ 실시간 변환으로 입력 즉시 결과를 표시",
        "🎯 정확한 색상 값 계산 및 변환",
        "🌈 140개 이상의 표준 CSS 색상 이름 지원",
        "📱 반응형 디자인으로 모바일에 완벽하게 적합"
      ],
      "faq": [
        {
          "question": "어떤 색상 형식을 지원합니까?",
          "answer": "도구는 네 가지 주요 형식을 지원합니다: 1) HEX 형식(#FF5733 또는 #F53 등); 2) RGB 형식(rgb(255, 87, 51)); 3) HSL 형식(hsl(9, 100%, 60%)); 4) CSS 색상 이름(red, blue, cornflowerblue 등 140+ 표준 색상 이름)."
        },
        {
          "question": "HEX, RGB와 HSL의 차이점은 무엇입니까?",
          "answer": "HEX는 16진수 색상 표기이며 CSS와 디자인 도구에서 자주 사용됩니다. RGB는 빨강, 초록, 파랑의 3원색에 기반하며 각 채널은 0-255입니다. HSL은 색상(Hue), 채도(Saturation), 명도(Lightness)를 기반으로 하여 인간이 색을 직관적으로 이해하기에 더 적합하며 색상의 밝기와 선명도를 조정하기 쉽습니다."
        },
        {
          "question": "CSS 색상 이름은 어떻게 사용합니까?",
          "answer": "표준 CSS 색상은 140개 이상이며 해당하는 이름이 있습니다. 다른 색상은 '해당하는 CSS 색상 이름이 없습니다'로 표시됩니다. 표준 CSS 색상 이름을 직접 입력하면 됩니다(예: red, blue, green, coral 등). 도구가 자동으로 인식하여 다른 형식으로 변환합니다."
        },
        {
          "question": "변환 결과의 정확도는 어떻습니까?",
          "answer": "도구는 표준 색상 변환 알고리즘을 사용하여 변환 결과의 정확성을 보장합니다. RGB와 HEX 간의 변환은 손실이 없고, HSL과 RGB 사이에는 미세한 정밀도 차이가 있을 수 있습니다(일반적으로 1 미만). 그러나 실제 사용에서는 무시해도 됩니다."
        },
        {
          "question": "일부 색상에는 CSS 이름이 매칭되지 않는 이유가 무엇입니까?",
          "answer": "CSS는 147개의 표준 색상 이름(투명 포함)만 정의합니다. 나머지 수백만 가지 색상에는 이름이 없습니다. 입력한 색상이 표준 색상 목록에 없으면 도구는 '해당하는 CSS 색상 이름이 없습니다'를 표시하지만 HEX, RGB 및 HSL 형식은 여전히 정상적으로 표시됩니다."
        }
      ],
      "meta": {
        "title": "색상 변환기 - HEX RGB HSL CSS 형식 변환",
        "description": "온라인 색상 형식 변환 도구로 HEX, RGB, HSL 및 CSS 색상 이름 간의 상호 변환을 지원하며, 실시간 미리보기와 원클릭 복사를 제공합니다.",
        "keywords": "색상 변환기, HEX를 RGB로 변환, 색상 형식"
      }
    },
    "docker-run-to-compose": {
      "name": "Docker Run을 Docker Compose로",
      "description": "docker run 명령을 docker-compose.yml 형식으로 변환",
      "input_title": "Docker Run 명령 입력",
      "input_desc": "도커 run 명령을 붙여넣기 또는 입력",
      "input_placeholder": "도커 run 명령을 입력하세요... 예: docker run -d -p 8080:80 --name my-nginx -v /data:/usr/share/nginx/html nginx:latest",
      "output_title": "Docker Compose 구성",
      "output_desc": "생성된 docker-compose.yml 내용",
      "output_placeholder": "변환된 docker-compose.yml 내용이 여기에 표시됩니다...",
      "convert_button": "Compose로 변환",
      "invalid_command": "유효하지 않은 docker run 명령",
      "conversion_failed": "변환 실패, 명령 형식을 확인하십시오",
      "tips_title": "사용 방법",
      "tip1_title": "명령 형식",
      "tip1_desc": "표준 docker run 명령을 지원하며 다양한 매개변수와 옵션을 포함합니다",
      "tip2_title": "지원 매개변수",
      "tip2_desc": "지원 -p/-d/-v/-e/--name/--network/--restart 등 일반적인 매개변수",
      "tip3_title": "이미지 이름",
      "tip3_desc": "명령에 유효한 이미지 이름과 태그가 포함되어 있는지 확인하십시오",
      "tip4_title": "데이터 보안",
      "tip4_desc": "모든 변환은 로컬에서 완료되며, 명령과 구성은 서버로 업로드되지 않습니다",
      "introduction": "Docker Run 转 Compose 도구는 Docker 사용자를 위해 설계된 명령 변환 도구로, docker run 명령을 표준 docker-compose.yml 구성 파일 형식으로 빠르게 변환할 수 있습니다. docker-compose는 docker run 명령을 직접 사용하는 것에 비해 구성은 더 명확하고 관리하기 쉬우며 다중 컨테이너 오케스트레이션을 지원하는 등 이점이 있습니다. 이 도구는 docker run 명령의 다양한 매개변수를 스마트하게 해석하고 표준 YAML 구성을 자동으로 생성하여 Docker 컨테이너 관리 효율을 크게 향상시키며, DevOps 및 개발자의 든든한 조수입니다.",
      "features": [
        "🔄 도커 run 명령을 스마트하게 해석하고 다양한 매개변수 형식을 지원합니다",
        "📝 표준 docker-compose.yml 구성을 자동으로 생성합니다",
        "🎯 포트 매핑, 볼륨 마운트, 환경 변수 등 일반적으로 사용되는 구성을 지원합니다",
        "⚡ 실시간 변환으로 즉시 사용 가능한 compose 구성을 생성합니다",
        "📋 생성된 구성을 한 번의 클릭으로 클립보드에 복사합니다",
        "💾 docker-compose.yml 파일로 직접 다운로드를 지원합니다",
        "🔒 로컬 처리로 명령과 구성을 안전하게 보호합니다",
        "📱 반응형 디자인으로 모바일 및 데스크톱을 지원합니다"
      ],
      "faq": [
        {
          "question": "왜 docker run을 docker-compose로 변환해야 하나요?",
          "answer": "docker-compose는 더 나은 구성 관리 방법을 제공합니다: 1) 구성 파일화로 버전 관리와 팀 협업에 용이; 2) 다중 컨테이너 오케스트레이션을 지원하여 서비스 의존 관계를 정의할 수 있음; 3) 모든 서비스를 한 번에 시작하고 중지할 수 있음; 4) 구성이 더 명확하고 읽기 쉬워 유지 보수 및 수정이 용이; 5) 환경 변수와 구성 재사용을 지원. 장기간 유지가 필요한 프로젝트의 경우 docker-compose를 사용하는 것이 모범 사례입니다."
        },
        {
          "question": "도구는 어떤 docker run 매개변수를 지원합니까?",
          "answer": "도구는 대부분의 일반 매개변수를 지원하며, 예를 들어: -p/--publish(포트 매핑), -v/--volume(볼륨 마운트), -e/--env(환경 변수), --name(컨테이너 이름), -d/--detach(백그라운드 실행), --restart(재시작 정책), --network(네트워크 구성), --link(컨테이너 연결), --workdir(작업 디렉토리), --user(사용자) 등을 포함합니다. 지원되지 않는 매개변수의 경우 도구는 원래 명령을 보존하여 수동으로 조정할 수 있도록 합니다."
        },
        {
          "question": "생성된 docker-compose.yml를 바로 사용할 수 있나요?",
          "answer": "생성된 구성 파일은 docker-compose 규칙을 따르며 대부분의 경우 바로 사용할 수 있습니다. 다만 실제 필요에 따라 확인하고 조정하는 것을 권장합니다: 1) 포트 매핑이 올바른지 확인; 2) 볼륨 마운트 경로 확인; 3) 환경 변수 설정 확인; 4) 필요에 따라 네트워크 구성, 리소스 제한 등 고급 옵션 추가; 5) 복잡한 시나리오의 경우 구성 구조를 수동으로 최적화해야 할 수 있습니다."
        },
        {
          "question": "민감한 정보를 포함한 명령을 어떻게 처리합니까?",
          "answer": "모든 변환 작업은 사용자의 브라우저 로컬에서 처리되며 명령 내용은 어떤 서버에도 업로드되지 않습니다. 다만 아래를 권장합니다: 1) 변환 전 민감한 비밀번호와 키를 제거하십시오; 2) 환경 변수 파일(.env)로 민감한 구성을 관리하십시오; 3) 생성된 구성 파일에 평문 비밀번호가 포함되지 않도록 하십시오; 4) docker-compose.yml을 .gitignore에 추가해 민감 정보를 포함하지 않도록 하십시오; 5) 운영 환경의 민감한 데이터를 관리하기 위해 Docker Secrets를 사용하십시오."
        },
        {
          "question": "변환 실패 시 어떻게 해결합니까?",
          "answer": "변환 실패의 일반적인 원인과 해결 방법: 1) 명령이 'docker run'으로 시작하는지 확인; 2) 이미지 이름이 포함되어 있는지 확인; 3) 매개변수 형식이 올바른지 확인(예: -p 8080:80); 4) 명령의 특수 문자와 이스케이프 문자를 제거; 5) 명령을 단순화하고 매개변수를 하나씩 추가; 6) 도구가 제공하는 예시 명령 형식을 참조. 문제가 지속되면 기본 구성을 수동으로 작성한 후 조정."
        }
      ],
      "meta": {
        "title": "Docker Run→Compose 도구 - 명령을 YAML 구성으로 변환",
        "description": "온라인 Docker Run 명령 변환 도구로, docker run 명령을 빠르게 docker-compose.yml 구성 파일로 변환하여 컨테이너 관리 효율을 높입니다.",
        "keywords": "Docker Compose, 컨테이너 오케스트레이션, Docker 변환"
      }
    },
    "base64-file-converter": {
      "name": "Base64 이미지 변환기",
      "description": "이미지와 Base64 인코딩 간 상호 변환 도구",
      "image_description": "전문적인 이미지 Base64 인코딩 변환 도구로, JPG, PNG, GIF, WebP 등 일반적인 이미지 포맷을 지원합니다",
      "image_to_base64": "이미지를 Base64로 변환",
      "base64_to_image": "Base64를 이미지로 변환",
      "upload_image": "이미지 업로드",
      "drag_image": "여기에 이미지를 드래그 앤 드롭하거나 이미지를 선택하세요",
      "supported_formats": "JPG, PNG, GIF, WebP, SVG, BMP 형식을 지원하며 최대 5MB",
      "image_info": "이미지 정보",
      "image_name": "이미지 이름",
      "image_size": "이미지 크기",
      "image_type": "이미지 형식",
      "download_image": "이미지 다운로드",
      "convert_to_image": "이미지로 변환",
      "convert_to_see_image": "변환 버튼을 클릭하여 이미지를 확인하세요.",
      "copy_base64": "Base64 복사",
      "base64_input": "Base64 입력",
      "base64_output": "Base64 출력",
      "base64_input_placeholder": "Base64 인코딩 내용을 붙여넣으세요...",
      "base64_output_placeholder": "Base64 인코딩 결과가 여기에 표시됩니다...",
      "input_title": "입력 영역",
      "output_title": "출력 결과",
      "output_desc": "변환된 결과",
      "image_preview": "이미지 미리보기",
      "no_image_selected": "이미지가 선택되지 않았습니다.",
      "invalid_base64": "유효하지 않은 Base64 형식",
      "image_too_large": "이미지가 너무 큽니다. 5MB 이하로 업로드하는 것을 권장합니다.",
      "invalid_image_format": "지원되지 않는 이미지 형식입니다. JPG, PNG, GIF, WebP, SVG 또는 BMP 형식을 선택해 주세요.",
      "convert_success": "변환 성공",
      "mode_switch": "변환 모드",
      "tips_title": "사용 설명",
      "tip1_title": "이미지를 Base64로 변환",
      "tip1_desc": "이미지 파일을 선택하면 시스템이 자동으로 Base64 인코딩으로 변환되며, CSS Data URLs, 웹 개발, 데이터 전송 등 다양한 상황에 적합합니다.",
      "tip2_title": "Base64를 이미지로 변환",
      "tip2_desc": "Base64 인코딩 내용을 붙여넣으면 원래 이미지로 복원되어 미리보기나 다운로드가 가능합니다.",
      "tip3_title": "이미지 크기 제한",
      "tip3_desc": "변환 성능을 보장하기 위해 업로드하는 이미지 크기를 5MB를 넘지 않는 것이 좋습니다.",
      "tip4_title": "안전 및 개인정보 보호",
      "tip4_desc": "모든 변환 작업은 브라우저에서 로컬로 수행되며 이미지가 서버로 업로드되지 않습니다. 데이터 보안을 보장합니다.",
      "introduction": "Base64 이미지 변환기는 전문 이미지 인코딩 변환 도구로, JPG, PNG, GIF, WebP 등 이미지 형식과 Base64 인코딩 간의 양방향 변환을 지원합니다. 웹 개발, 웹 디자인, 이메일 내 이미지 삽입, API 인터페이스 등에서 널리 사용됩니다. 브라우저 로컬에서 처리되므로 이미지의 보안성과 개인정보 보호를 보장하며, 개발자와 디자이너의 필수 도구입니다.",
      "features": [
        "🔄 이미지와 Base64의 양방향 변환 지원",
        "🖼️ 다양한 이미지 형식(JPG, PNG, GIF, WebP, SVG, BMP) 지원",
        "🎯 실시간 변환, 즉시 결과 표시",
        "🔒 로컬 처리로 파일 프라이버시 안전 보장",
        "📱 반응형 디자인, 모바일에서의 조작 지원",
        "💾 실시간 미리보기 및 변환된 이미지를 한 번의 클릭으로 다운로드",
        "📋 편리한 Base64 코드 복사 기능",
        "🚀 고성능 처리로 대형 이미지 변환 지원"
      ],
      "faq": [
        {
          "question": "Base64 이미지 변환기는 어떤 이미지 형식을 지원합니까?",
          "answer": "이 도구는 JPEG, JPG, PNG, GIF, WebP, SVG, BMP 등 모든 주요 이미지 형식의 변환을 지원합니다. 어떤 형식이든 정확하게 Base64 인코딩으로 변환하고 원래 이미지로 완벽하게 복원할 수 있습니다. 도구는 이미지 유형을 자동으로 감지하고 변환 과정을 최적화합니다."
        },
        {
          "question": "이미지 크기에 어떤 제한이 있으며, 왜 제한합니까?",
          "answer": "최적의 변환 성능과 사용자 경험을 보장하기 위해 단일 이미지는 10MB를 넘지 않도록 권장합니다. 이 제한은 주로 다음을 고려합니다: 1) 브라우저 메모리 사용 효율; 2) 변환 속도와 응답성; 3) 페이지 렉 방지. 더 큰 이미지의 경우 먼저 압축하거나 스케일링하는 것을 권장합니다."
        },
        {
          "question": "Base64 인코딩 후 이미지 용량이 대략 얼마나 커지나요?",
          "answer": "Base64 인코딩은 이미지 용량을 대략 33% 증가시킵니다. 이는 Base64가 64개의 출력 문자를 사용하여 256가지 바이트 값을 표현하기 때문이며, 원래의 3바이트가 4개의 Base64 문자로 인코딩됩니다. 크기가 늘어나지만 텍스트 프로토콜에서 이진 이미지 데이터를 전송할 수 있게 해주며, 이는 CSS Data URLs 및 Web 개발에서 매우 유용합니다."
        },
        {
          "question": "변환 과정은 안전합니까? 이미지가 서버에 업로드되나요?",
          "answer": "완전히 안전합니다! 모든 변환 작업은 브라우저에서 로컬로 수행되며 이미지 내용은 사용자의 기기를 벗어나지 않습니다. 우리는 어떤 이미지 데이터도 업로드, 저장 또는 기록하지 않습니다. 이러한 로컬 처리 방식은 최고 수준의 개인정보 보호를 보장하며 민감한 이미지 및 개인 사진 처리에 적합합니다."
        },
        {
          "question": "변환된 Base64 인코딩이 올바른지 어떻게 확인합니까?",
          "answer": "다음과 같이 검증할 수 있습니다: 1) Base64를 이미지로 변환하는 기능으로 역방향 검증; 2) Base64 문자열이 A-Z, a-z, 0-9, +, /, = 문자만 포함하는지 확인; 3) 문자열 길이가 4의 배수인지 확인; 4) 이미지는 데이터 URL로 브라우저에서 미리보기하여 확인."
        }
      ],
      "meta": {
        "title": "Base64 이미지 변환기 - 이미지와 인코딩의 상호 변환",
        "description": "온라인 Base64 이미지 변환 도구로, 이미지와 Base64 인코딩의 양방향 변환을 지원하며 웹 개발과 데이터 임베드에 적합합니다.",
        "keywords": "Base64 이미지, 이미지 인코딩, Base64 변환"
      }
    },
    "image-to-dot-matrix": {
      "name": "이미지를 도트 매트릭스로 변환",
      "description": "이미지나 텍스트를 도트 매트릭스 효과로 변환하며 다양한 스타일을 지원합니다.",
      "mode_title": "입력 모드",
      "mode_desc": "이미지나 텍스트를 사용해 도트 매트릭스 생성 선택",
      "mode_image": "이미지 모드",
      "mode_text": "텍스트 모드",
      "upload_title": "이미지 업로드",
      "upload_desc": "이미지 파일 선택 또는 드래그 앤 드롭",
      "text_input_title": "텍스트 입력",
      "text_input_desc": "변환할 텍스트 내용 입력",
      "text_content_label": "텍스트 내용",
      "text_placeholder": "문자, 알파벳 또는 숫자 입력...",
      "font_size_label": "글꼴 크기",
      "font_weight_label": "글꼴 굵기",
      "font_family_label": "글꼴",
      "font_normal": "일반",
      "font_bold": "굵게",
      "no_text_input": "텍스트 내용을 입력하세요",
      "settings_title": "도트 매트릭스 설정",
      "settings_desc": "도트 매트릭스 효과 매개변수 사용자 정의",
      "preview_title": "도트 매트릭스 미리보기",
      "preview_desc": "실시간 도트 매트릭스 효과 미리보기",
      "original_preview": "원본 이미지",
      "drag_image": "여기에 이미지를 드래그 앤 드롭하거나 선택하세요",
      "supported_formats": "JPG, PNG, GIF, WebP 형식 지원, 최대 10MB",
      "no_image": "이미지가 선택되지 않음",
      "image_info": "이미지 정보",
      "original_size": "원본 크기",
      "file_size": "파일 크기",
      "dot_size_label": "점 크기",
      "dot_size_hint": "점의 직경 크기(픽셀)",
      "dot_spacing_label": "점 간격",
      "dot_spacing_hint": "점들 사이 간격",
      "dot_shape_label": "점 모양",
      "shape_circle": "원형",
      "shape_square": "사각형",
      "shape_diamond": "마름모",
      "shape_hexagon": "육각형",
      "color_mode_label": "색상 모드",
      "mode_grayscale": "그레이스케일",
      "mode_blackwhite": "흑백",
      "mode_color": "컬러",
      "threshold_label": "흑백 임계값",
      "threshold_hint": "흑백 모드의 그레이스케일 임계값(0-255)",
      "invert_label": "색상 반전",
      "background_label": "배경색",
      "background_transparent": "투명",
      "background_white": "흰색",
      "background_black": "검은색",
      "background_custom": "사용자 정의",
      "processing": "처리 중...",
      "generate_button": "도트 매트릭스 생성",
      "download_png": "PNG 다운로드",
      "download_svg": "SVG 다운로드",
      "copy_image": "이미지 복사",
      "reset": "설정 초기화",
      "image_too_large": "이미지가 너무 큽니다. 10MB 미만의 파일을 선택해 주세요.",
      "invalid_format": "지원되지 않는 이미지 형식",
      "generation_failed": "생성에 실패했습니다. 다시 시도해 주세요.",
      "tips_title": "사용 방법",
      "tip1_title": "점 크기",
      "tip1_desc": "더 작은 점 크기는 더 섬세한 효과를 만들어 내지만 파일 크기가 더 커집니다. 3-5픽셀부터 시도해 보시길 권장합니다.",
      "tip2_title": "색상 모드",
      "tip2_desc": "그레이스케일 모드는 밝고 어두움의 층을 보존하고, 흑백 모드는 높은 대비 효과를 만들어 내며, 컬러 모드는 원색을 유지합니다.",
      "tip3_title": "점 모양",
      "tip3_desc": "다양한 모양이 서로 다른 예술 효과를 만들어 냅니다. 원형은 가장 일반적이고, 정사각형은 픽셀 스타일에 적합하며, 마름모와 육각형은 더 창의적입니다.",
      "tip4_title": "내보내기 형식",
      "tip4_desc": "PNG는 바로 사용하기에 적합하고, SVG는 벡터 형식으로 무한대로 확대해도 왜곡이 없습니다.",
      "introduction": "도트 격자 그림 도구는 전문적인 이미지 예술 효과 생성기로, 일반 이미지를 독특한 도트 격자 스타일의 그림으로 변환합니다. 다양한 도트 모양, 색상 모드 및 매개변수 조정을 지원하여 복고풍, 현대미술, 예술 등 다양한 시각 효과를 창출할 수 있습니다. 그래픽 디자인, 포스터 제작, 웹 디자인, 인쇄물 등 분야에 광범위하게 활용되며 디자이너와 창의적 작업자의 든든한 조력자입니다.",
      "features": [
        "🖼️ JPG, PNG, GIF, WebP 등 다양한 이미지 형식을 지원합니다.",
        "⚙️ 유연한 도트 격자 매개변수: 크기, 간격, 모양 조정 가능",
        "🎨 다양한 색상 모드: 그레이스케일, 흑백, 컬러",
        "🔷 네 가지 점 모양: 원형, 사각형, 마름모, 육각형",
        "👁️ 실시간 미리보기, 즉시 효과 확인",
        "💾 이중 형식으로 내보내기: PNG 비트맵과 SVG 벡터 그래프",
        "🔒 로컬 처리로 이미지 프라이버시를 안전하게 보장",
        "⚡ 고성능 처리, 대형 이미지 지원"
      ],
      "faq": [
        {
          "question": "도트 격자 그림은 어떤 상황에 사용되나요?",
          "answer": "도트 격자 그림은 광범위하게 활용됩니다: 1) 복고풍 디자인으로 초기 인쇄 효과를 모방; 2) 현대 미술 창작으로 독특한 시각 효과를 창출; 3) 웹 디자인의 배경 및 장식 요소; 4) 포스터 및 인쇄물 디자인; 5) 브랜드 비주얼 아이덴티티 시스템; 6) 디지털 아트와 NFT 창작. 도트 격자 효과는 일반 이미지를 독특한 예술적 감성과 첨단 기술 감각으로 표현할 수 있습니다."
        },
        {
          "question": "적절한 점 크기와 간격은 어떻게 선택하나요?",
          "answer": "점 크기와 간격의 선택은 사용 맥락에 따라 달라집니다: 소형 이미지의 경우 더 작은 점(2-4픽셀)을 사용하는 것이 좋고, 대형 이미지의 경우 더 큰 점(5-10픽셀)을 사용할 수 있습니다. 간격이 커질수록 이미지는 더 추상적이고, 간격이 작아질수록 세부 정보가 더 선명합니다. 기본값으로 먼저 생성한 후 효과에 따라 미세 조정하는 것이 권장됩니다. 인쇄 출력의 경우 더 작은 점을 사용해 더 많은 세부 정보를 보존할 수 있습니다."
        },
        {
          "question": "다른 색상 모드의 차이점은 무엇입니까?",
          "answer": "세 가지 색상 모드 각각의 특징: 1) 그레이스케일 모드는 이미지의 밝고 어두운 층을 보존하여 세부 정보가 풍부한 환경에 적합; 2) 흑백 모드는 순수 흑과 백 두 가지 색만으로 높은 대비를 만들어 간결한 스타일과 로고 디자인에 적합; 3) 컬러 모드는 원본 색상을 보존하여 예술 창작 및 컬러 인쇄에 적합. 사용할 최종 용도와 시각적 요구를 고려해 선택하십시오."
        },
        {
          "question": "PNG와 SVG 형식은 어떻게 선택해야 하나요?",
          "answer": "PNG는 비트맷 형식으로 바로 사용 및 공유에 적합합니다. 파일은 비교적 크지만 호환성이 좋고, 웹 페이지 표시나 소셜 미디어 등에 적합합니다. SVG는 벡터 형식으로 무한대로 확대해도 왜곡이 없고 파일 크기가 보통 더 작아 확대가 필요한 상황에 적합합니다(예: 인쇄, 로고, 아이콘 디자인). 나중 편집이나 대폭 확대가 필요하면 SVG를 선택하는 것이 좋고, 신속한 사용과 공유가 필요하면 PNG를 선택하세요."
        },
        {
          "question": "대용량 이미지를 처리할 때 성능은 어떻습니까?",
          "answer": "도구는 성능 최적화를 통해 대형 크기의 이미지를 원활하게 처리할 수 있습니다. 최상의 사용 경험을 보장하려면 이미지가 10MB를 초과하지 않는 것이 좋습니다. 초대형 이미지의 경우 처리 속도를 보장하기 위해 점 크기가 자동으로 조정됩니다. 모든 처리는 브라우저 로컬에서 이루어지며 서버에 업로드되지 않아 이미지의 보안을 보장합니다. 성능 문제가 발생하면 먼저 이미지 크기를 줄이거나 점 크기를 키우세요."
        }
      ],
      "meta": {
        "title": "이미지를 도트 격자 그림으로 변환 도구 - 픽셀 아트 효과 생성",
        "description": "온라인 이미지 도트 격자 그림 도구로, 다양한 도트 모양과 색상 모드를 지원하며, 독특한 도트 격자 예술 효과를 생성합니다. 디자인과 창의적 프로젝트에 적합합니다.",
        "keywords": "도트 격자 그림, 픽셀 아트, 이미지 효과"
      }
    },
    "git-cheatsheet": {
      "name": "Git 빠른 참조표",
      "description": "Git 자주 사용하는 명령어 빠른 참조표, Git 명령어를 빠르게 찾고 복사합니다.",
      "search_placeholder": "Git 명령어 검색...",
      "copy_success": "명령어가 복사되었습니다.",
      "no_results": "일치하는 명령어를 찾을 수 없습니다.",
      "all_categories": "전체",
      "categories": {
        "setup": "설정 및 초기화",
        "basic": "기본 작업",
        "branch": "브랜치 관리",
        "remote": "원격 저장소",
        "undo": "취소 및 되돌리기",
        "stash": "스테이징 작업",
        "log": "로그 보기",
        "tag": "태그 관리",
        "merge": "병합 및 리베이스",
        "advanced": "고급 작업"
      },
      "commands": {
        "setup": {
          "init": {
            "cmd": "git init",
            "desc": "현재 디렉터리에 새 Git 저장소를 초기화합니다."
          },
          "init_bare": {
            "cmd": "git init --bare",
            "desc": "베어 저장소를 초기화합니다 (작업 디렉터리 없음, 서버용)."
          },
          "clone": {
            "cmd": "git clone <url>",
            "desc": "원격 저장소를 로컬로 복제합니다."
          },
          "clone_depth": {
            "cmd": "git clone --depth 1 <url>",
            "desc": "얕은 복제, 최신 커밋만 가져옵니다 (시간 및 공간 절약)."
          },
          "clone_branch": {
            "cmd": "git clone -b <branch> <url>",
            "desc": "지정된 브랜치를 복제합니다."
          },
          "config_name": {
            "cmd": "git config --global user.name \"이름\"",
            "desc": "전역 사용자 이름을 설정합니다."
          },
          "config_email": {
            "cmd": "git config --global user.email \"이메일\"",
            "desc": "전역 이메일을 설정합니다."
          },
          "config_list": {
            "cmd": "git config --list",
            "desc": "모든 설정을 확인합니다."
          },
          "config_editor": {
            "cmd": "git config --global core.editor vim",
            "desc": "기본 편집기를 설정합니다."
          }
        },
        "basic": {
          "status": {
            "cmd": "git status",
            "desc": "작업 영역 상태를 확인합니다."
          },
          "status_short": {
            "cmd": "git status -s",
            "desc": "간결한 상태를 확인합니다."
          },
          "add": {
            "cmd": "git add <file>",
            "desc": "파일을 스테이징 영역에 추가합니다."
          },
          "add_all": {
            "cmd": "git add .",
            "desc": "모든 변경 사항을 스테이징 영역에 추가합니다."
          },
          "add_patch": {
            "cmd": "git add -p",
            "desc": "대화형 추가, 일부 변경 사항을 선택할 수 있습니다."
          },
          "commit": {
            "cmd": "git commit -m \"커밋 메시지\"",
            "desc": "스테이징 영역의 변경 사항을 커밋합니다."
          },
          "commit_amend": {
            "cmd": "git commit --amend",
            "desc": "마지막 커밋을 수정합니다."
          },
          "commit_amend_no_edit": {
            "cmd": "git commit --amend --no-edit",
            "desc": "마지막 커밋을 수정합니다 (커밋 메시지 수정 없이)."
          },
          "commit_all": {
            "cmd": "git commit -am \"커밋 메시지\"",
            "desc": "추적 중인 모든 파일의 변경 사항을 추가하고 커밋"
          },
          "diff": {
            "cmd": "git diff",
            "desc": "작업 영역과 스테이징 영역의 차이점 보기"
          },
          "diff_staged": {
            "cmd": "git diff --staged",
            "desc": "스테이징 영역과 마지막 커밋의 차이점 보기"
          },
          "diff_commit": {
            "cmd": "git diff <commit1> <commit2>",
            "desc": "두 커밋의 차이점 비교"
          },
          "rm": {
            "cmd": "git rm <file>",
            "desc": "파일 삭제 및 삭제 작업 기록"
          },
          "rm_cached": {
            "cmd": "git rm --cached <file>",
            "desc": "스테이징 영역에서 파일 제거, 작업 영역 파일은 유지"
          },
          "mv": {
            "cmd": "git mv <old> <new>",
            "desc": "파일 이동 또는 이름 변경"
          }
        },
        "branch": {
          "list": {
            "cmd": "git branch",
            "desc": "로컬 브랜치 목록 표시"
          },
          "list_all": {
            "cmd": "git branch -a",
            "desc": "모든 브랜치 목록 표시 (원격 포함)"
          },
          "list_remote": {
            "cmd": "git branch -r",
            "desc": "원격 브랜치 목록 표시"
          },
          "create": {
            "cmd": "git branch <branch>",
            "desc": "새 브랜치 생성"
          },
          "checkout": {
            "cmd": "git checkout <branch>",
            "desc": "지정된 브랜치로 전환"
          },
          "checkout_create": {
            "cmd": "git checkout -b <branch>",
            "desc": "새 브랜치 생성 및 전환"
          },
          "switch": {
            "cmd": "git switch <branch>",
            "desc": "브랜치 전환 (Git 2.23+)"
          },
          "switch_create": {
            "cmd": "git switch -c <branch>",
            "desc": "브랜치 생성 및 전환 (Git 2.23+)"
          },
          "delete": {
            "cmd": "git branch -d <branch>",
            "desc": "병합된 브랜치 삭제"
          },
          "delete_force": {
            "cmd": "git branch -D <branch>",
            "desc": "강제로 브랜치 삭제"
          },
          "rename": {
            "cmd": "git branch -m <old> <new>",
            "desc": "브랜치 이름 변경"
          },
          "upstream": {
            "cmd": "git branch -u origin/<branch>",
            "desc": "현재 브랜치의 업스트림 브랜치 설정"
          },
          "verbose": {
            "cmd": "git branch -vv",
            "desc": "브랜치 상세 정보 보기 (업스트림 브랜치 포함)"
          }
        },
        "remote": {
          "list": {
            "cmd": "git remote -v",
            "desc": "원격 저장소 목록 보기"
          },
          "add": {
            "cmd": "git remote add <name> <url>",
            "desc": "원격 저장소 추가"
          },
          "remove": {
            "cmd": "git remote remove <name>",
            "desc": "원격 저장소 제거"
          },
          "rename": {
            "cmd": "git remote rename <old> <new>",
            "desc": "원격 저장소 이름 변경"
          },
          "show": {
            "cmd": "git remote show <name>",
            "desc": "원격 저장소 상세 정보 보기"
          },
          "set_url": {
            "cmd": "git remote set-url <name> <url>",
            "desc": "원격 저장소 URL 수정"
          },
          "fetch": {
            "cmd": "git fetch <remote>",
            "desc": "원격 저장소 업데이트 가져오기"
          },
          "fetch_all": {
            "cmd": "git fetch --all",
            "desc": "모든 원격 저장소 업데이트 가져오기"
          },
          "fetch_prune": {
            "cmd": "git fetch -p",
            "desc": "업데이트를 가져오고 삭제된 원격 브랜치 정리"
          },
          "pull": {
            "cmd": "git pull",
            "desc": "원격 브랜치 가져와 병합"
          },
          "pull_rebase": {
            "cmd": "git pull --rebase",
            "desc": "가져와 리베이스"
          },
          "push": {
            "cmd": "git push",
            "desc": "원격 저장소로 푸시"
          },
          "push_upstream": {
            "cmd": "git push -u origin <branch>",
            "desc": "푸시하고 업스트림 브랜치 설정"
          },
          "push_force": {
            "cmd": "git push --force",
            "desc": "강제 푸시 (주의해서 사용)"
          },
          "push_force_lease": {
            "cmd": "git push --force-with-lease",
            "desc": "안전한 강제 푸시"
          },
          "push_tags": {
            "cmd": "git push --tags",
            "desc": "모든 태그 푸시"
          },
          "push_delete": {
            "cmd": "git push origin --delete <branch>",
            "desc": "원격 브랜치 삭제"
          }
        },
        "undo": {
          "restore": {
            "cmd": "git restore <file>",
            "desc": "작업 영역 변경 사항 버리기 (Git 2.23+)"
          },
          "restore_staged": {
            "cmd": "git restore --staged <file>",
            "desc": "스테이징 취소 (Git 2.23+)"
          },
          "checkout_file": {
            "cmd": "git checkout -- <file>",
            "desc": "작업 영역 변경 사항 버리기 (이전 방식)"
          },
          "reset_soft": {
            "cmd": "git reset --soft HEAD~1",
            "desc": "마지막 커밋 되돌리기, 변경 사항은 스테이징 영역에 유지"
          },
          "reset_mixed": {
            "cmd": "git reset HEAD~1",
            "desc": "마지막 커밋 되돌리기, 변경 사항은 작업 영역에 유지"
          },
          "reset_hard": {
            "cmd": "git reset --hard HEAD~1",
            "desc": "마지막 커밋 되돌리기, 모든 변경 사항 버리기"
          },
          "reset_file": {
            "cmd": "git reset HEAD <file>",
            "desc": "지정된 파일 스테이징 취소"
          },
          "reset_commit": {
            "cmd": "git reset --hard <commit>",
            "desc": "지정된 커밋으로 재설정"
          },
          "revert": {
            "cmd": "git revert <commit>",
            "desc": "지정된 커밋을 되돌리는 새 커밋 생성"
          },
          "revert_no_commit": {
            "cmd": "git revert -n <commit>",
            "desc": "커밋 되돌리기 (자동 커밋 안 함)"
          },
          "clean": {
            "cmd": "git clean -fd",
            "desc": "추적되지 않은 파일 및 디렉터리 삭제"
          },
          "clean_dry": {
            "cmd": "git clean -nd",
            "desc": "삭제될 추적되지 않은 파일 미리 보기"
          }
        },
        "stash": {
          "save": {
            "cmd": "git stash",
            "desc": "현재 변경 사항 임시 저장"
          },
          "save_message": {
            "cmd": "git stash save \"설명 메시지\"",
            "desc": "임시 저장하고 설명 추가"
          },
          "save_untracked": {
            "cmd": "git stash -u",
            "desc": "추적되지 않은 파일 포함하여 임시 저장"
          },
          "list": {
            "cmd": "git stash list",
            "desc": "임시 저장 목록 보기"
          },
          "pop": {
            "cmd": "git stash pop",
            "desc": "가장 최근 임시 저장 복원 및 삭제"
          },
          "apply": {
            "cmd": "git stash apply",
            "desc": "가장 최근 임시 저장 복원 (삭제 안 함)"
          },
          "apply_index": {
            "cmd": "git stash apply stash@{n}",
            "desc": "지정된 임시 저장 복원"
          },
          "drop": {
            "cmd": "git stash drop",
            "desc": "가장 최근 임시 저장 삭제"
          },
          "drop_index": {
            "cmd": "git stash drop stash@{n}",
            "desc": "지정된 임시 저장 삭제"
          },
          "clear": {
            "cmd": "git stash clear",
            "desc": "모든 임시 저장 비우기"
          },
          "show": {
            "cmd": "git stash show -p",
            "desc": "임시 저장의 상세 내용 보기"
          },
          "branch": {
            "cmd": "git stash branch <branch>",
            "desc": "임시 저장에서 새 브랜치 생성"
          }
        },
        "log": {
          "basic": {
            "cmd": "git log",
            "desc": "커밋 히스토리 보기"
          },
          "oneline": {
            "cmd": "git log --oneline",
            "desc": "한 줄로 커밋 히스토리 표시"
          },
          "graph": {
            "cmd": "git log --oneline --graph",
            "desc": "그래프로 커밋 히스토리 표시"
          },
          "all": {
            "cmd": "git log --oneline --graph --all",
            "desc": "모든 브랜치의 커밋 히스토리 표시"
          },
          "number": {
            "cmd": "git log -n <number>",
            "desc": "최근 n개 커밋 표시"
          },
          "author": {
            "cmd": "git log --author=\"이름\"",
            "desc": "작성자별로 커밋 필터링"
          },
          "since": {
            "cmd": "git log --since=\"2024-01-01\"",
            "desc": "날짜별로 커밋 필터링"
          },
          "grep": {
            "cmd": "git log --grep=\"키워드\"",
            "desc": "커밋 메시지로 검색"
          },
          "file": {
            "cmd": "git log -- <file>",
            "desc": "지정된 파일의 커밋 히스토리 보기"
          },
          "stat": {
            "cmd": "git log --stat",
            "desc": "각 커밋의 파일 변경 통계 표시"
          },
          "patch": {
            "cmd": "git log -p",
            "desc": "각 커밋의 상세 차이점 표시"
          },
          "reflog": {
            "cmd": "git reflog",
            "desc": "모든 작업 기록 보기 (삭제된 커밋 포함)"
          },
          "show": {
            "cmd": "git show <commit>",
            "desc": "지정된 커밋의 상세 정보 보기"
          },
          "shortlog": {
            "cmd": "git shortlog -sn",
            "desc": "작성자별 커밋 수 통계"
          }
        },
        "tag": {
          "list": {
            "cmd": "git tag",
            "desc": "모든 태그 나열"
          },
          "list_pattern": {
            "cmd": "git tag -l \"v1.*\"",
            "desc": "패턴으로 태그 나열"
          },
          "create": {
            "cmd": "git tag <tagname>",
            "desc": "경량 태그 생성"
          },
          "create_annotated": {
            "cmd": "git tag -a <tagname> -m \"설명\"",
            "desc": "주석이 있는 태그 생성"
          },
          "create_commit": {
            "cmd": "git tag <tagname> <commit>",
            "desc": "특정 커밋에 태그 생성"
          },
          "show": {
            "cmd": "git show <tagname>",
            "desc": "태그 상세 보기"
          },
          "delete": {
            "cmd": "git tag -d <tagname>",
            "desc": "로컬 태그 삭제"
          },
          "push": {
            "cmd": "git push origin <tagname>",
            "desc": "단일 태그 푸시"
          },
          "push_all": {
            "cmd": "git push origin --tags",
            "desc": "모든 태그 푸시"
          },
          "delete_remote": {
            "cmd": "git push origin --delete <tagname>",
            "desc": "원격 태그 삭제"
          }
        },
        "merge": {
          "merge": {
            "cmd": "git merge <branch>",
            "desc": "지정된 브랜치를 현재 브랜치로 병합"
          },
          "merge_no_ff": {
            "cmd": "git merge --no-ff <branch>",
            "desc": "빨리 감기(fast-forward) 없이 병합, 브랜치 히스토리 유지"
          },
          "merge_squash": {
            "cmd": "git merge --squash <branch>",
            "desc": "스쿼시 병합, 모든 커밋을 하나로 병합"
          },
          "merge_abort": {
            "cmd": "git merge --abort",
            "desc": "병합 중단"
          },
          "rebase": {
            "cmd": "git rebase <branch>",
            "desc": "현재 브랜치를 지정된 브랜치로 리베이스"
          },
          "rebase_interactive": {
            "cmd": "git rebase -i HEAD~n",
            "desc": "최근 n개 커밋을 대화형 리베이스"
          },
          "rebase_continue": {
            "cmd": "git rebase --continue",
            "desc": "리베이스 계속"
          },
          "rebase_abort": {
            "cmd": "git rebase --abort",
            "desc": "리베이스 중단"
          },
          "cherry_pick": {
            "cmd": "git cherry-pick <commit>",
            "desc": "지정된 커밋을 현재 브랜치에 적용"
          },
          "cherry_pick_no_commit": {
            "cmd": "git cherry-pick -n <commit>",
            "desc": "커밋을 적용하지만 자동 커밋하지 않음"
          }
        },
        "advanced": {
          "bisect_start": {
            "cmd": "git bisect start",
            "desc": "이분 탐색 시작 (문제 커밋 찾기)"
          },
          "bisect_bad": {
            "cmd": "git bisect bad",
            "desc": "현재 커밋을 문제 있음으로 표시"
          },
          "bisect_good": {
            "cmd": "git bisect good <commit>",
            "desc": "지정된 커밋을 정상으로 표시"
          },
          "bisect_reset": {
            "cmd": "git bisect reset",
            "desc": "이분 탐색 종료"
          },
          "blame": {
            "cmd": "git blame <file>",
            "desc": "파일 각 줄의 마지막 수정자 보기"
          },
          "blame_line": {
            "cmd": "git blame -L 10,20 <파일>",
            "desc": "지정된 행 범위의 수정자 확인"
          },
          "worktree_add": {
            "cmd": "git worktree add <경로> <브랜치>",
            "desc": "새 작업 트리 생성"
          },
          "worktree_list": {
            "cmd": "git worktree list",
            "desc": "모든 작업 트리 나열"
          },
          "submodule_add": {
            "cmd": "git submodule add <URL> <경로>",
            "desc": "서브모듈 추가"
          },
          "submodule_update": {
            "cmd": "git submodule update --init --recursive",
            "desc": "모든 서브모듈 초기화 및 업데이트"
          },
          "archive": {
            "cmd": "git archive --format=zip HEAD > archive.zip",
            "desc": "저장소를 zip 파일로 압축"
          },
          "gc": {
            "cmd": "git gc",
            "desc": "저장소 정리 및 최적화"
          },
          "fsck": {
            "cmd": "git fsck",
            "desc": "저장소 무결성 검사"
          }
        }
      },
      "introduction": "Git 치트 시트는 개발자를 위해 특별히 설계된 Git 명령 빠른 참조 도구입니다. 기본 작업부터 고급 기술까지 모든 일반적인 명령을 다루며, 기능별로 분류되어 빠른 검색 및 원클릭 복사를 지원합니다. Git 초보자든 숙련된 개발자든 여기에서 필요한 명령을 빠르게 찾을 수 있습니다. 모든 명령에는 명확한 중국어 설명이 제공되어 Git을 더 잘 이해하고 사용하는 데 도움이 됩니다.",
      "features": [
        "10개 이상의 카테고리, Git의 모든 일반적인 시나리오를 다룸",
        "100개 이상의 일반적인 명령, 기초부터 고급까지 모두 수록",
        "키워드 검색 지원, 필요한 명령을 빠르게 찾을 수 있음",
        "원클릭 명령 복사, 작업 효율성 향상",
        "명확한 중국어 설명, 이해하고 배우기 쉬움",
        "카테고리별 탐색 및 필터링, 관련 명령을 빠르게 찾을 수 있음",
        "반응형 디자인, 모바일 기기에서 확인 가능",
        "로컬 실행, 네트워크 없이 사용 가능"
      ],
      "faq": [
        {
          "question": "Git 치트 시트가 왜 필요한가요?",
          "answer": "Git 명령은 많고 매개변수가 복잡하여 숙련된 개발자라도 모든 명령을 기억하기 어렵습니다. 치트 시트는 명령을 빠르게 찾고 복사하여 문서 검색 시간을 절약하고 개발 효율성을 높이는 데 도움이 됩니다."
        },
        {
          "question": "치트 시트에는 어떤 명령 카테고리가 포함되어 있나요?",
          "answer": "치트 시트에는 10가지 주요 카테고리가 포함되어 있습니다: 구성 및 초기화, 기본 작업, 브랜치 관리, 원격 저장소, 취소 및 되돌리기, 스테이징 작업, 로그 보기, 태그 관리, 병합 및 리베이스, 고급 작업. 일상적인 개발에서 거의 모든 Git 사용 시나리오를 다룹니다."
        },
        {
          "question": "필요한 명령을 어떻게 빠르게 찾을 수 있나요?",
          "answer": "상단의 검색창에 키워드를 입력하여 검색하거나, 카테고리 태그를 클릭하여 특정 유형의 명령을 필터링할 수 있습니다. 검색은 명령 이름과 설명의 퍼지 매칭을 지원합니다."
        },
        {
          "question": "복사한 명령을 바로 사용할 수 있나요?",
          "answer": "대부분의 명령은 바로 사용할 수 있지만, 일부 명령의 <매개변수>는 실제 값으로 대체해야 합니다. 예를 들어 git clone <url>의 <url>은 실제 저장소 주소로 대체해야 합니다."
        },
        {
          "question": "치트 시트는 계속 업데이트되나요?",
          "answer": "네, 새로운 유용한 명령과 기술을 추가하여 최신 Git 버전과 동기화되도록 치트 시트를 계속 업데이트할 것입니다."
        }
      ],
      "meta": {
        "title": "Git 치트 시트 - 일반적인 명령 빠른 참조",
        "description": "Git 일반 명령 치트 시트, 구성, 브랜치, 원격, 취소, 스테이징, 로그, 태그, 병합 등 모든 시나리오를 다루며 검색 및 원클릭 복사를 지원합니다.",
        "keywords": "Git 치트 시트, Git 명령, Git 튜토리얼, 버전 관리"
      }
    },
    "i18n-json-translator": {
      "name": "i18n JSON 번역기",
      "description": "JSON 언어 파일을 한 번에 번역합니다. 기본 내용을 붙여넣고 대상 언어를 선택하면, 도구가 평탄화된 키를 사용하여 OpenRouter API를 호출합니다.",
      "workflow_badge": "i18n 워크플로",
      "source_title": "원본 JSON",
      "source_desc": "기본 언어 JSON 파일을 붙여넣거나 드래그 앤 드롭하세요. 문자열 값만 번역 API로 전송됩니다.",
      "source_language": "원본 언어",
      "target_languages": "목표 언어",
      "source_placeholder": "여기에 JSON 언어 데이터를 붙여넣으세요...",
      "translate_button": "번역 시작",
      "sample_button": "샘플 데이터 사용",
      "options_title": "번역 선호 설정",
      "options_desc": "API를 호출하기 전에 자리 표시자, 보조 텍스트 및 HTML 조각의 처리 방식을 제어합니다.",
      "option_placeholders": "자리 표시자 잠금",
      "option_placeholders_desc": "ICU 변수(예: name, count)를 보호하여 번역된 사본이 정확한 태그를 유지하도록 합니다.",
      "option_skip_short": "짧은 문자열 건너뛰기",
      "option_skip_short_desc": "선택한 길이보다 짧은 보조 태그 무시",
      "option_strip_html": "HTML 태그 제거",
      "option_strip_html_desc": "모델에 텍스트를 보내기 전에 HTML 태그를 제거하여 태그가 손상되지 않도록 합니다.",
      "option_include_keys": "키 프롬프트 전송",
      "option_include_keys_desc": "모델에 각 문장에 대한 더 많은 맥락을 제공하기 위해 키 경로를 첨부합니다.",
      "entries_detected": "번역이 필요한 {count}개의 문자열이 감지되었습니다.",
      "progress_title": "번역 대기열",
      "progress_desc": "각 언어의 대기, 번역 또는 완료 상태를 모니터링합니다.",
      "completed": "완료",
      "failed": "실패",
      "progress": "진행 상황",
      "entries": "항목",
      "status": "상태",
      "queued": "대기 중",
      "translating": "번역 중",
      "output_title": "번역 결과",
      "output_desc": "번역된 언어 JSON을 보기, 복사 또는 다운로드합니다. 문자열이 아닌 필드는 변하지 않습니다.",
      "output_placeholder": "여기에서 각 언어를 미리 보려면 번역을 실행하십시오.",
      "key_path": "키 경로",
      "preview": "미리보기",
      "preview_limit": "미리보기에서 +{count}개의 항목이 숨겨져 있습니다.",
      "copied_message": "{language} 번역이 클립보드에 복사되었습니다.",
      "select_language_tip": "최소 하나의 대상 언어를 선택해 주세요.",
      "invalid_json": "원본 JSON에 구문 오류가 포함되어 있습니다.",
      "empty_entries": "문자열 값이 감지되지 않았습니다. JSON에 텍스트 노드가 포함되어 있는지 확인하십시오.",
      "introduction": "i18n JSON 번역기는 팀 현지화 애플리케이션의 사용 방식을 간소화합니다. 중첩된 언어 파일을 평면화하고 키 경로를 보존하며 문자열 값만 OpenRouter 기반 백엔드로 보냅니다. API 응답 후 도구가 원래 구조를 재구성하여 몇 초 안에 생산 준비 파일을 복사하거나 다운로드할 수 있습니다.",
      "features": [
        "중첩된 각 키를 자동으로 추출하고 번역 후 정확한 JSON 구조를 복원합니다.",
        "문자열 값만 백엔드로 전송되므로 숫자, 부울 값 및 메타데이터는 변하지 않습니다.",
        "LLM으로 콘텐츠를 보내기 전에 자리 표시자, HTML 태그 및 짧은 보조 태그를 고급으로 보호합니다.",
        "언어 큐는 실시간 상태를 제공하고 각 번역 항목에 대한 차이가 잘 보이는 미리보기를 제공합니다.",
        "실시간으로 각 언어의 완전히 포맷된 언어 파일을 복사하거나 다운로드할 수 있습니다.",
        "클라이언트 측 100% 파싱으로, 번역이 필요한 값만 API 엔드포인트로 전송됩니다."
      ],
      "faq": [
        {
          "question": "도구가 제 API에 어떤 페이로드를 보낼까요?",
          "answer": "각 요청은 sourceLanguage, targetLanguage, entries({key, value} 배열) 및 선택 옵션을 /api/i18n-translate로 게시합니다. 이 페이로드를 OpenRouter 또는 임의의 커스텀 번역 서비스로 전달할 수 있습니다."
        },
        {
          "question": "자리 표시자와 HTML을 어떻게 보호합니까?",
          "answer": "자리 표시자 잠금 또는 HTML 제거 옵션을 활성화합니다. 도구는 ICU 표기({count})를 완전하게 유지하며, 텍스트를 모델에 보내기 전에 HTML 태그를 제거해 태그 손상을 방지할 수 있습니다."
        },
        {
          "question": "한 번에 여러 언어를 번역할 수 있나요?",
          "answer": "네, 필요에 따라 대상 언어의 수를 임의로 추가할 수 있습니다. UI는 각 언어를 독립적으로 추적하므로 어떤 언어가 대기 중, 실행 중, 완료되었거나 실패했는지 알 수 있습니다."
        }
      ],
      "meta": {
        "title": "i18n JSON 번역기 - OpenRouter를 사용한 로컬라이즈 JSON 파일",
        "description": "언어 JSON 키를 평면화하여 OpenRouter 번역 백엔드로 전송하고 파일을 자동으로 재구성합니다.",
        "keywords": "i18n.json 번역기, OpenRouter, 로컬라이제이션, 번역 도구"
      }
    },
    "text-counter": {
      "name": "텍스트 문자 통계",
      "description": "텍스트의 문자 수, 단어 수, 줄 수 등의 정보 통계",
      "placeholder": "통계할 텍스트를 입력하거나 붙여넣으세요...",
      "input_title": "텍스트 입력",
      "input_desc": "통계할 텍스트 내용을 입력하세요",
      "output_title": "통계 결과",
      "output_desc": "텍스트의 각 지표를 실시간으로 통계",
      "copy_stats": "통계 결과 복사",
      "stats": {
        "characters": "총 문자 수",
        "characters_no_spaces": "문자 수 (공백 제외)",
        "words": "총 단어 수",
        "chinese_words": "중국어 단어 수",
        "english_words": "영어 단어 수",
        "numbers": "숫자 개수",
        "sentences": "문장 수",
        "paragraphs": "단락 수",
        "lines": "줄 수",
        "bytes": "바이트 수 (UTF-8)"
      },
      "introduction": "텍스트 문자 통계 도구는 총 문자 수, 공백 제외 문자 수, 중국어 단어 수, 영어 단어 수, 숫자 개수, 문장 수, 단락 수, 줄 수, 바이트 수 등 텍스트의 다양한 지표를 실시간으로 통계할 수 있는 전문 텍스트 분석 도구입니다. 중국어와 영어 혼합 텍스트의 정확한 통계를 지원하며, 글쓰기 단어 수 통계, 논문 단어 수 확인, 소셜 미디어 콘텐츠 제한, SEO 기사 분석 등 다양한 시나리오에 널리 사용됩니다. 이 도구는 사용자 텍스트의 개인 정보 보호를 위해 완전히 로컬에서 실행됩니다.",
      "features": [
        "📊 실시간 통계, 입력 즉시 각 지표 표시",
        "🇨🇳 중국어 문자와 영어 단어 정확히 인식",
        "🔢 숫자, 문장, 단락 스마트 통계",
        "📝 중국어 및 영어 혼합 텍스트 통계 지원",
        "📋 모든 통계 결과 원클릭 복사",
        "🎯 UTF-8 바이트 수 정확한 계산",
        "🔒 로컬 처리, 텍스트 개인 정보 보호",
        "📱 반응형 디자인, 모바일 지원"
      ],
      "faq": [
        {
          "question": "문자 수와 단어 수의 차이점은 무엇인가요?",
          "answer": "문자 수는 공백, 구두점 등을 포함하여 텍스트의 모든 문자를 통계합니다. 반면 단어 수는 의미 있는 단어 단위를 의미합니다. 중국어는 개별 글자로 계산하고, 영어는 공백으로 구분된 단어로 계산하며, 연속된 숫자는 하나의 숫자로 간주합니다. 예를 들어 'Hello 你好 123'의 문자 수는 12이고, 단어 수는 3(영어 단어 1개 + 중국어 글자 2개 + 숫자 1개)입니다."
        },
        {
          "question": "논문 또는 기사의 단어 수를 어떻게 통계하나요?",
          "answer": "텍스트를 입력 상자에 붙여넣으면 도구가 자동으로 각 지표를 통계합니다. 학술 논문의 경우 일반적으로 '총 단어 수'(중국어 글자 + 영어 단어) 또는 '문자 수(공백 제외)'에 중점을 둡니다. 저널 및 학교마다 단어 수 통계 기준이 다를 수 있으므로 특정 요구 사항에 따라 적절한 지표를 선택하는 것이 좋습니다."
        },
        {
          "question": "문장 수는 어떻게 계산되나요?",
          "answer": "문장 수는 중국어 및 영어의 마침표(. 또는 。), 물음표(? 또는 ？), 느낌표(! 또는 !)를 구분 기호로 사용하여 계산됩니다. 연속된 구두점은 한 번만 계산되며, 공백 내용은 문장 수에 포함되지 않습니다."
        },
        {
          "question": "UTF-8 바이트 수는 어디에 사용되나요?",
          "answer": "UTF-8 바이트 수는 텍스트가 저장되거나 전송될 때의 실제 크기를 나타냅니다. 중국어 문자는 UTF-8 인코딩에서 일반적으로 3바이트를 차지하고, 영어 문자는 1바이트를 차지합니다. 이는 데이터베이스 필드 길이 제한, API 요청 크기 제한, 파일 크기 추정 등 다양한 시나리오에서 매우 유용합니다."
        },
        {
          "question": "이 도구는 어떤 언어의 통계를 지원하나요?",
          "answer": "이 도구는 주로 중국어 및 영어 혼합 텍스트에 최적화되어 있으며, 중국어 문자와 영어 단어를 정확하게 구분할 수 있습니다. 다른 언어(예: 일본어, 한국어 등)의 경우 문자 수로 통계됩니다. 숫자 통계는 모든 아라비아 숫자를 지원합니다."
        }
      ],
      "meta": {
        "title": "텍스트 문자 통계 도구 - 온라인 단어 수 통계",
        "description": "무료 온라인 텍스트 문자 통계 도구, 문자 수, 단어 수, 줄 수, 단락 수를 실시간으로 통계하며, 중국어 및 영어 혼합 텍스트를 지원하여 글쓰기 및 콘텐츠 제작에 적합합니다.",
        "keywords": "문자 통계, 단어 수 통계, 텍스트 통계"
      }
    }
  },
  "seo": {
    "tool_introduction": "도구 소개",
    "tool_features": "주요 특징",
    "frequently_asked_questions": "자주 묻는 질문",
    "related_tools": "관련 도구",
    "all_tools": "모든 도구",
    "more_tools": "더 많은 도구",
    "tools_in_category": "동종 도구",
    "popular_tools": "인기 도구",
    "expand": "펼치기",
    "collapse": "접기",
    "view_tool": "도구 보기",
    "try_now": "지금 바로 사용하기",
    "showing_tools": "현재 {current}개 도구 표시, 총 {total}개 사용 가능"
  }
}